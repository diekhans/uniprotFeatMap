#!/usr/bin/env python3

import sys
import os.path as osp
import argparse
import multiprocessing as mp
from functools import partial
from pycbio.sys import fileOps
from pycbio.sys.profile import Profile
from pycbio.hgdata.decoration import BedBlock

sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))
from uniprotmap import OutOfSyncError
from uniprotmap.interproscan import interproAnnotsLoad
from uniprotmap.interproDecorators import InterproDecoration, AnnotCategory, INTERPRO_COLOR, OTHER_COLOR
from uniprotmap.metadata import xrefToItemArgs
from uniprotmap.decoratorsBuilder import buildDecorators

def parseArgs():
    desc = """
    Convert InterproScan annotations alignments create by interproAnnotsMap
    to a decorator BED file in interproDecoration.as format.  Possibly filtering
    the results.
    """
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--nprocs", type=int, default=1,
                        help="""number of processers to use""")
    parser.add_argument("--batchSize", type=int, default=250,
                        help="""size of batch to sent to task""")
    parser.add_argument("--featTypesTsv",
                        help="""unique category and feature types for constructing track filters (output)""")
    parser.add_argument("interproAnnotTsv",
                        help="""Interpro annotations TSV from interproToTab (input)""")
    parser.add_argument("annot2GenomePsl",
                        help="""Interpro annotations mapped to genome from interproAnnotsMap (input). For cross-species mapping, this will
                        be the target species genome.""")
    parser.add_argument("annot2GenomeRefTsv",
                        help="""association of annotations to mapped transcripts (input)""")
    parser.add_argument("annotDecoratorBed",
                        help="""annotation decorator BED file (output)""")
    profiler = Profile(parser)
    opts = parser.parse_args()
    profiler.setup(opts)
    return opts

def includeAnnot(annot):
    "filter for desired annotations"
    return annot.status

def getAnnotCatFields(annot):
    "fields based on if type of annotation"
    if annot.interpro_accession:
        return (annot.interpro_accession,
                annot.interpro_description,
                AnnotCategory.InterPro,
                INTERPRO_COLOR)
    else:
        return (annot.signature_accession,
                annot.signature_description,
                AnnotCategory.other,
                OTHER_COLOR)

def makeDecorator(annot, annotPsl, annot2GenomeRef):
    accession, description, annotCategory, color = getAnnotCatFields(annot)
    bedBlocks = [BedBlock(pb.tStart, pb.tEnd) for pb in annotPsl.blocks]
    itemName, itemStart, itemEnd = xrefToItemArgs(annot2GenomeRef)

    return InterproDecoration(annotPsl.tName, bedBlocks, annot.annotId, annotPsl.qStrand, color,
                              itemName, itemStart, itemEnd, None, None,
                              proteinAcc=annot.protein_accession,
                              analysis=annot.analysis,
                              accession=accession,
                              description=description,
                              annotCategory=annotCategory,
                              interproAcc=annot.interpro_accession,
                              interproDesc=annot.interpro_description,
                              signatureAcc=annot.signature_accession,
                              signatureDesc=annot.signature_description)

class AnnotationProcessor:
    """Class used to generate decorators."""

    def __init__(self, interproAnnotTsv):
        self.interproAnnotTbl = interproAnnotsLoad(interproAnnotTsv)

    def _buildAnnotation(self, annotPsl, annot, annot2GenomeRef):
        return makeDecorator(annot, annotPsl, annot2GenomeRef)

    def _createAnnot(self, annotMapping):
        if annotMapping.annotPsl is None:
            raise OutOfSyncError(f"annotation {annotMapping.annot2GenomeRef.annotId} does not have a corresponding alignment")
        annot = self.interproAnnotTbl.getByAnnotId(annotMapping.annot2GenomeRef.annotId)
        if includeAnnot(annot):
            return [self._buildAnnotation(annotMapping.annotPsl, annot, annotMapping.annot2GenomeRef)]
        else:
            return None

    def create(self, transAnnotMappings):
        beds = []
        for annotMapping in transAnnotMappings.annotMappings:
            bed = self._createAnnot(annotMapping)
            if bed is not None:
                beds.extend(bed)
        return beds


def getFeatType(decoBed):
    """use to return tuple for collecting feature types that used when defining filters"""
    return (decoBed.analysis, decoBed.accession, decoBed.description, decoBed.annotCategory)

def writeFeatTypes(featTypes, featTypesTsv):
    with fileOps.opengz(featTypesTsv, 'w') as fh:
        fileOps.prRowv(fh, "analysis", "accession", "description", "annotCategory")
        for ft in sorted(featTypes):
            fileOps.prRowv(fh, *ft)

def interproAnnotsToDecorators(interproAnnotTsv, annot2GenomePslFile, annot2GenomeRefTsv,
                               annotDecoratorBedFile, nprocs, batchSize, featTypesTsv):
    annotProcFunc = partial(AnnotationProcessor, interproAnnotTsv)

    featTypes = buildDecorators(annotProcFunc, getFeatType,
                                annot2GenomePslFile, annot2GenomeRefTsv,
                                annotDecoratorBedFile, nprocs, batchSize)
    if featTypesTsv is not None:
        writeFeatTypes(featTypes, featTypesTsv)

def main(opts):
    interproAnnotsToDecorators(opts.interproAnnotTsv, opts.annot2GenomePsl, opts.annot2GenomeRefTsv,
                               opts.annotDecoratorBed, opts.nprocs, opts.batchSize,
                               opts.featTypesTsv)

if __name__ == '__main__':
    mp.set_start_method("fork")
    main(parseArgs())
