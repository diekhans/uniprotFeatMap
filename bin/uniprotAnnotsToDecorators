#!/usr/bin/env python3

import sys
import os.path as osp
import argparse
import multiprocessing as mp
from collections import namedtuple
import pipettor
from pycbio.sys import fileOps
from pycbio.sys.profile import Profile
from pycbio.sys.svgcolors import SvgColors
from pycbio.hgdata.psl import PslReader
from pycbio.hgdata.bed import Bed, BedBlock

sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))
from protmap.uniprot import UniProtMetaTbl, UniProtAnnotTbl, UniProtDataSet
from protmap.uniprot import getAnnotColor, getProblemColor, getAnnotBedName, getAnnotCategory, calcTransMatchStatus
from protmap.gencode import GencodeData
from protmap.annotTransRef import AnnotTransRefs
from protmap.mappingAnalysis import analyzeFeatureMapping

def parseArgs():
    desc = """
    Convert domain annotations alignments create by uniprotMapAnnots
    to a decorator BED file in uniprotDecoration.as format.  Possibly filtering
    the results.
    """
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--nprocs", type=int, default=1,
                        help="number of processes to use for tasks")
    parser.add_argument("--batchSize", type=int, default=1000,
                        help="size of batch to sent to task")
    parser.add_argument("--dataset", type=UniProtDataSet, choices=UniProtDataSet, default=UniProtDataSet.SwissProt,
                        help="Is the UniProt dataset SwissProt or TrEMBL?")
    parser.add_argument("--featTypesTsv",
                        help="output unique category and feature types for constructing track filters")
    parser.add_argument("uniprotMetaTsv",
                        help="Uniprot metadata in TSV format")
    parser.add_argument("uniprotAnnotsTsv",
                        help="Uniprot annotations TSV from uniprotToTab")
    parser.add_argument("annotGenomePsl",
                        help="Uniprot annotations mapped to genome from uniprotMapAnnots")
    parser.add_argument("annotTransRefTsv",
                        help="association of annotations to mapped transcripts")
    parser.add_argument("transGenomePsl",
                        help="transcript genome alignment; often from genePredToPsl")
    parser.add_argument("annotDecoratorBedFile",
                        help="annotation decorator BED file output")
    profiler = Profile(parser)
    opts = parser.parse_args()
    profiler.setup(opts)
    return opts

# threshold for generating one glyph rather than two for insertion
FEAT_SHORT_INS_THRESHOLD = 4

class BedPlusColumns(namedtuple("BedPlusColumns",
                                ("decoratedItem", "style", "fillColor",
                                 "glyph", "dataSet", "uniprotAcc", "transMatchStatus",
                                 "category", "categoryName", "description",
                                 "shortFeatType", "featType", "shortName",
                                 "longName", "comment", "disease"))):
    "extra BED columns"
    __slots__ = ()

##
# Note: for now, greatly limit the features until we can
# determine how to better group them. There are 43 short
# feature types.
##
shortFeatTypeInclude = frozenset([
    "domain",
    "zinc finger",
    "enzyme act site",
])

# shortFeatType to not use
_shortFeatTypesToSkip = frozenset([
    'splicing',
])
def includeAnnot(annot):
    "filter for desired annotations"
    return annot.shortFeatType not in _shortFeatTypesToSkip


def createDecoratorBed(chrom, strand, bedBlocks, annot, annotTransRef, transMatchStatus, name, color, fillColor, style,
                       dataSet, description, *, glyph=None, thickStart=None, thickEnd=None):
    "This creates a decorator BED, with annotation options are supplied."
    start, end = bedBlocks[0].start, bedBlocks[-1].end
    decoratedItem = annotTransRef.transcriptPos + ':' + annotTransRef.transcriptId
    if glyph is None:
        glyph = ""
    if fillColor is None:
        fillColor = color
    if thickStart is None:
        thickStart = start
    if thickEnd is None:
        thickEnd = end
    category, categoryName = getAnnotCategory(annot)
    extraCols = BedPlusColumns(decoratedItem, style, fillColor.toRgba8Str(), glyph,
                               dataSet, annot.acc, transMatchStatus, category, categoryName, description,
                               annot.shortFeatType, annot.featType, annot.shortName, annot.longName,
                               annot.comment, annot.disease)
    return Bed(chrom, start, end, name,
               strand=strand, thickStart=thickStart, thickEnd=thickEnd,
               blocks=bedBlocks, numStdCols=12,
               itemRgb=color.toRgb8Str(),
               extraCols=extraCols)

def makeBlockDeco(chrom, strand, bedBlocks, annot, annotTransRef, transMatchStatus, name, color, fillColor,
                  dataSet, description):
    return createDecoratorBed(chrom, strand, bedBlocks, annot, annotTransRef, transMatchStatus, name, color, fillColor, "block",
                              dataSet, description)

def makeGlyphDeco(tStart, tEnd, name, description, color, annotPsl, annot, annotTransRef, transMatchStatus, dataSet):
    bedBlocks = [BedBlock(tStart, tEnd)]
    return createDecoratorBed(annotPsl.tName, annotPsl.qStrand, bedBlocks, annot, annotTransRef, transMatchStatus,
                              name, color, color, "glyph", dataSet, description, glyph="triangle")

def mkMainAnnotDecorator(annotPsl, annot, annotTransRef, transMatchStatus, dataSet, featIndels):
    description = annot.featType
    annotColor = getAnnotColor(annot, dataSet)
    fillColor = annotColor.setAlpha(0.5)
    color = annotColor if len(featIndels) == 0 else getProblemColor(annot, dataSet)
    bedBlocks = [BedBlock(pb.tStart, pb.tEnd) for pb in annotPsl.blocks]
    return makeBlockDeco(annotPsl.tName, annotPsl.qStrand, bedBlocks, annot, annotTransRef, transMatchStatus,
                         getAnnotBedName(annot), color, fillColor,
                         dataSet, description)

def makeFeatDelAnnot(featIndel, annotPsl, annot, annotTransRef, transMatchStatus, dataSet):
    name = f"del {featIndel.length}: "
    description = name
    yield makeGlyphDeco(featIndel.tStart, featIndel.tEnd,
                        name, description, SvgColors.red, annotPsl, annot, annotTransRef, transMatchStatus, dataSet)

def makeFeatShortInsAnnot(featIndel, annotPsl, annot, annotTransRef, transMatchStatus, dataSet):
    pos = featIndel.tStart + (featIndel.length // 2)
    name = f"ins {featIndel.length}: " + getAnnotBedName(annot)
    description = name
    yield makeGlyphDeco(pos, pos + 1,
                        name, description, SvgColors.red, annotPsl, annot, annotTransRef, transMatchStatus, dataSet)

def makeFeatLongInsAnnot(featIndel, annotPsl, annot, annotTransRef, transMatchStatus, dataSet):
    # make long bar
    namePre = f"ins {featIndel.length}: "
    name = namePre + getAnnotBedName(annot)
    description = name
    color = SvgColors.red
    bedBlocks = [BedBlock(featIndel.tStart, featIndel.tEnd)]
    yield makeBlockDeco(annotPsl.tName, annotPsl.qStrand, bedBlocks, annot, annotTransRef, transMatchStatus,
                        name, color, color, dataSet, description)

def makeFeatInsAnnot(featIndel, annotPsl, annot, annotTransRef, transMatchStatus, dataSet):
    if featIndel.length <= FEAT_SHORT_INS_THRESHOLD:
        yield from makeFeatShortInsAnnot(featIndel, annotPsl, annot, annotTransRef, transMatchStatus, dataSet)
    else:
        yield from makeFeatLongInsAnnot(featIndel, annotPsl, annot, annotTransRef, transMatchStatus, dataSet)

def makeFeatIndelAnnot(featIndel, annotPsl, annot, annotTransRef, transMatchStatus, dataSet):
    """Make glyphs or block for a particular INDEL in the annotation. A generator
    so more than one can be returned"""
    if featIndel.isFeatDel:
        yield from makeFeatDelAnnot(featIndel, annotPsl, annot, annotTransRef, transMatchStatus, dataSet)
    else:
        yield from makeFeatInsAnnot(featIndel, annotPsl, annot, annotTransRef, transMatchStatus, dataSet)

def mkBrokenAnnotDecorators(transPsl, annotPsl, annot, annotTransRef, transMatchStatus, dataSet, featIndels):
    "produces glyphs to mark were annotations are broken in the mappings"
    glyphBeds = []
    for featIndel in featIndels:
        glyphBeds.extend(makeFeatIndelAnnot(featIndel, annotPsl, annot, annotTransRef, transMatchStatus, dataSet))
    return glyphBeds

def buildAnnotation(transPsl, annotPsl, annot, annotTransRef, transMatchStatus, dataSet, decoratorBeds):
    "converts BEDs to strings so this work is distributed"
    featIndels = analyzeFeatureMapping(transPsl, annotPsl)
    bed = mkMainAnnotDecorator(annotPsl, annot, annotTransRef, transMatchStatus, dataSet, featIndels)
    decoratorBeds.append(bed)
    if len(featIndels) > 0:
        glyphBeds = mkBrokenAnnotDecorators(transPsl, annotPsl, annot, annotTransRef, transMatchStatus, dataSet, featIndels)
        decoratorBeds.extend(glyphBeds)

class AnnotationProcessor:
    """Class used to generate annotations.  This is used to move most of the
    processing to the pool sub-process"""

    def __init__(self, uniprotMetaTsv, uniprotAnnotsTsv, annotTransRefTsv, transGenomePsl, dataSet):
        self.dataSet = dataSet
        self.uniprotMetaTbl = UniProtMetaTbl(uniprotMetaTsv)
        self.uniprotAnnotTbl = UniProtAnnotTbl(uniprotAnnotsTsv)
        self.annotTransRefs = AnnotTransRefs(annotTransRefTsv)
        self.transGenomeAlns = GencodeData(transGenomePsl)

    def _buildAnnotation(self, annotPsl, annot, alignIdx, decoratorBeds):
        annotTransRef = self.annotTransRefs.get(annotPsl.qName, alignIdx)
        uniprotMeta = self.uniprotMetaTbl.getByAcc(annot.acc)
        transMatchStatus = calcTransMatchStatus(uniprotMeta, annotTransRef.transcriptId)
        transPsl = self.transGenomeAlns.get(annotTransRef.transcriptId, annotPsl.tName)
        buildAnnotation(transPsl, annotPsl, annot, annotTransRef, transMatchStatus, self.dataSet, decoratorBeds)

    def processBatch(self, alignBatch):
        decoratorBeds = []
        for annotPsl, alignIdx in alignBatch:
            annot = self.uniprotAnnotTbl.getByAnnotId(annotPsl.qName)
            if includeAnnot(annot):
                self._buildAnnotation(annotPsl, annot, alignIdx, decoratorBeds)
        return decoratorBeds

def workerInit(uniprotMetaTsv, uniprotAnnotsTsv, annotTransRefTsv, transGenomePsl, dataSet):
    "sub-process setup"
    global gAnnotationProcessor
    gAnnotationProcessor = AnnotationProcessor(uniprotMetaTsv, uniprotAnnotsTsv, annotTransRefTsv, transGenomePsl, dataSet)

def worker(alignBatch):
    "sub-process worker"
    return gAnnotationProcessor.processBatch(alignBatch)

def annotGenomeBatchReader(annotGenomePslFile, batchSize):
    """return tuples of (annotPsl, alignIdx)"""
    alignIdx = 0
    alignBatch = []

    for annotPsl in PslReader(annotGenomePslFile):
        alignBatch.append((annotPsl, alignIdx))
        alignIdx += 1
        if len(alignBatch) >= batchSize:
            yield alignBatch
            alignBatch = []
    if len(alignBatch) > 0:
        yield alignBatch

def writeDecoratorBeds(batchBedsIter, annotDecoratorBedFile):
    "write results from multiprocessing task as they come back via an iter"
    featTypes = set()
    with fileOps.AtomicFileCreate(annotDecoratorBedFile) as tmpDecoBed:
        # also sort by target item and feature type for test reproducible
        with pipettor.Popen(["sort", "-k1,1", "-k2,2n", "-k3,3n", "-k13,13n", "-k4,4n"], 'w', stdout=tmpDecoBed) as decoBedFh:
            for batchBeds in batchBedsIter:
                for bed in batchBeds:
                    bed.write(decoBedFh)
                    featTypes.add((bed.extraCols.category, bed.extraCols.categoryName,
                                   bed.extraCols.featType, bed.extraCols.shortFeatType))
    return featTypes


def processSingle(uniprotMetaTsv, uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, transGenomePsl,
                  annotDecoratorBedFile, dataSet, batchSize):
    workerInit(uniprotMetaTsv, uniprotAnnotsTsv, annotTransRefTsv, transGenomePsl, dataSet)
    batchBedsIters = []
    for alignBatch in annotGenomeBatchReader(annotGenomePslFile, batchSize):
        batchBedsIters.append(worker(alignBatch))

    featTypes = writeDecoratorBeds(batchBedsIters, annotDecoratorBedFile)
    return featTypes

def processMulti(uniprotMetaTsv, uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, transGenomePsl,
                 annotDecoratorBedFile, dataSet, nprocs, batchSize):
    with mp.Pool(processes=nprocs, initializer=workerInit,
                 initargs=(uniprotMetaTsv, uniprotAnnotsTsv, annotTransRefTsv, transGenomePsl, dataSet)) as pool:
        batchBedsIter = pool.imap_unordered(worker,
                                            annotGenomeBatchReader(annotGenomePslFile, batchSize))
        featTypes = writeDecoratorBeds(batchBedsIter, annotDecoratorBedFile)
    return featTypes

def writeFeatTypes(featTypes, featTypesTsv):
    with fileOps.opengz(featTypesTsv, 'w') as fh:
        fileOps.prRowv(fh, "category", "categoryName", "featType", "shortFeatType")
        for ft in sorted(featTypes):
            fileOps.prRowv(fh, *ft)

def uniprotAnnotsToDecorators(uniprotMetaTsv, uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, transGenomePsl,
                              annotDecoratorBedFile, dataSet, nprocs, batchSize, featTypesTsv):
    # special case one process makes profiling easier
    if nprocs == 1:
        featTypes = processSingle(uniprotMetaTsv, uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, transGenomePsl,
                                  annotDecoratorBedFile, dataSet, batchSize)
    else:
        featTypes = processMulti(uniprotMetaTsv, uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, transGenomePsl,
                                 annotDecoratorBedFile, dataSet, nprocs, batchSize)
    if featTypesTsv is not None:
        writeFeatTypes(featTypes, featTypesTsv)

def main(opts):
    uniprotAnnotsToDecorators(opts.uniprotMetaTsv, opts.uniprotAnnotsTsv, opts.annotGenomePsl, opts.annotTransRefTsv,
                              opts.transGenomePsl, opts.annotDecoratorBedFile, opts.dataset, opts.nprocs, opts.batchSize,
                              opts.featTypesTsv)

if __name__ == '__main__':
    mp.set_start_method("fork")
    main(parseArgs())
