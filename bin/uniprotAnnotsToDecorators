#!/usr/bin/env python3

import sys
import os.path as osp
import argparse
import multiprocessing as mp
import pipettor
from pycbio.sys import fileOps
from pycbio.sys.profile import Profile
from pycbio.hgdata.psl import PslReader
from pycbio.hgdata.decoration import BedBlock, Glyph
from pycbio.hgdata.coords import Coords

sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))
from uniprotmap.uniprot import UniProtMetaTbl, UniProtAnnotTbl, UniProtDataSet, TransCategory
from uniprotmap.uniprotDecorators import (getAnnotColor, getProblemColor, getAnnotDescriptiveName, getAnnotCategory, calcTransCategory,
                                          getColorUses, decoratorBedSortOpts, makeColorDesc,
                                          UNIPROT_CANON_ISO_OUTLINE_COLOR, UNIPROT_NONCANON_ISO_OUTLINE_COLOR,
                                          FEAT_INSERTION_COLOR, FEAT_DELETION_COLOR, DecoratorType, FeatStatus,
                                          UniprotDecoration)
from uniprotmap.gencode import GencodeDataTbl
from uniprotmap.annotTransRef import AnnotTransRefs
from uniprotmap.mappingAnalysis import analyzeFeatureMapping, FeatureIndelType, getFeatureIndelText

class HelpColors(argparse.Action):
    "generate a help message on colors"
    def __call__(self, parser, namespace, values, option_string=None):
        descs = [makeColorDesc(UNIPROT_CANON_ISO_OUTLINE_COLOR,
                               "canonical transcript outline"),
                 makeColorDesc(UNIPROT_NONCANON_ISO_OUTLINE_COLOR,
                               "non-canonical isoform transcript outline"),
                 makeColorDesc(FEAT_INSERTION_COLOR,
                               "feature insertion"),
                 makeColorDesc(FEAT_DELETION_COLOR,
                               "feature deletion")]
        for (color, info) in getColorUses():
            descs.append(makeColorDesc(color, info))
        print("Color usage:")
        for desc in descs:
            print("   ", desc)
        parser.exit()


def parseArgs():
    desc = """
    Convert domain annotations alignments create by uniprotMapAnnots
    to a decorator BED file in uniprotDecoration.as format.  Possibly filtering
    the results.
    """
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument('--help-colors', action=HelpColors, nargs=0,
                        help='Show description of colors used, mostly for producing documentation')
    parser.add_argument("--nprocs", type=int, default=1,
                        help="number of processes to use for tasks")
    parser.add_argument("--batchSize", type=int, default=1000,
                        help="size of batch to sent to task")
    parser.add_argument("--dataset", type=UniProtDataSet, choices=UniProtDataSet, default=UniProtDataSet.SwissProt,
                        help="Is the UniProt dataset SwissProt or TrEMBL?")
    parser.add_argument("--featTypesTsv",
                        help="output unique category and feature types for constructing track filters")
    parser.add_argument("uniprotMetaTsv",
                        help="Uniprot metadata in TSV format")
    parser.add_argument("uniprotAnnotsTsv",
                        help="Uniprot annotations TSV from uniprotToTab")
    parser.add_argument("annotGenomePsl",
                        help="Uniprot annotations mapped to genome from uniprotMapAnnots")
    parser.add_argument("annotTransRefTsv",
                        help="association of annotations to mapped transcripts")
    parser.add_argument("transGenomePsl",
                        help="transcript genome alignment; often from genePredToPsl")
    parser.add_argument("annotDecoratorBedFile",
                        help="annotation decorator BED file output")
    profiler = Profile(parser)
    opts = parser.parse_args()
    profiler.setup(opts)
    return opts

##
# shortFeatType to not include in track.
#
_shortFeatTypesToSkip = frozenset([
    'splicing',
])
def includeAnnot(annot):
    "filter for desired annotations"
    return annot.shortFeatType not in _shortFeatTypesToSkip

def xrefToItemArgs(annotTransRef):
    "turns xref return into [name, start, end]"
    coords = Coords.parse(annotTransRef.transcriptPos)
    return annotTransRef.transcriptId, coords.start, coords.end


def makeDecorator(annotPsl, annot, annotTransRef, transCategory, featStatus, bedBlocks, name, color, fillColor,
                  dataSet, description, *, glyph=None):
    decoratorType = DecoratorType.feature if glyph is None else DecoratorType.disruption
    itemName, itemStart, itemEnd = xrefToItemArgs(annotTransRef)
    category, categoryName = getAnnotCategory(annot)
    return UniprotDecoration(annotPsl.tName, bedBlocks, name, annotPsl.qStrand, color,
                             itemName, itemStart, itemEnd, glyph, fillColor,
                             decoratorType=decoratorType, dataSet=dataSet,
                             uniprotAcc=annot.acc, transCategory=transCategory, featStatus=featStatus,
                             category=category, categoryName=categoryName, description=description,
                             shortFeatType=annot.shortFeatType, featType=annot.featType,
                             shortName=annot.shortName, longName=annot.longName,
                             comment=annot.comment, disease=annot.disease)

def makeBlockDeco(annotPsl, annot, annotTransRef, transCategory, featStatus, bedBlocks, name, color, fillColor,
                  dataSet, description):
    return makeDecorator(annotPsl, annot, annotTransRef, transCategory, featStatus, bedBlocks, name, color, fillColor,
                         dataSet, description)

def makeGlyphDeco(annotPsl, annot, annotTransRef, transCategory, featStatus, pos, name, color, dataSet, description):
    bedBlocks = [BedBlock(pos, pos)]
    return makeDecorator(annotPsl, annot, annotTransRef, transCategory, featStatus, bedBlocks, name, color, color,
                         dataSet, description, glyph=Glyph.Triangle)

def getBedName(annot):
    "change this function to get a different BED name (MUST be <= 255 characters)"
    return annot.shortFeatType

def getDescription(annot):
    "change this function to get a different description"
    return getAnnotDescriptiveName(annot)

def mkMainAnnotDecorator(annotPsl, annot, annotTransRef, transCategory, dataSet, featIndels):
    description = getDescription(annot)
    annotColor = getAnnotColor(annot, dataSet)
    fillColor = annotColor.setAlpha(0.5)
    featStatus = FeatStatus.complete if len(featIndels) == 0 else FeatStatus.disrupted
    if len(featIndels) > 0:
        color = getProblemColor(annot, dataSet)
    elif transCategory == TransCategory.noncanonical:
        color = UNIPROT_NONCANON_ISO_OUTLINE_COLOR
    else:
        color = UNIPROT_CANON_ISO_OUTLINE_COLOR
    bedBlocks = [BedBlock(pb.tStart, pb.tEnd) for pb in annotPsl.blocks]
    return makeBlockDeco(annotPsl, annot, annotTransRef, transCategory, featStatus, bedBlocks,
                         getBedName(annot), color, fillColor,
                         dataSet, description)

def getIndelName(featIndel, annot):
    return f"{featIndel.indelType}_{featIndel.length}_" + getBedName(annot)

def getIndelDesc(featIndel, annot):
    indelText = getFeatureIndelText(featIndel.indelType)
    return f"{indelText} of {featIndel.length} bases in " + getDescription(annot)

def makeFeatDelAnnot(featIndel, annotPsl, annot, annotTransRef, transCategory, dataSet):
    pos = (featIndel.tStart + featIndel.tEnd) // 2
    yield makeGlyphDeco(annotPsl, annot, annotTransRef, transCategory, featIndel.indelType, pos,
                        getIndelName(featIndel, annot), FEAT_DELETION_COLOR,
                        dataSet, getIndelDesc(featIndel, annot))

def makeFeatInsAnnot(featIndel, annotPsl, annot, annotTransRef, transCategory, dataSet):
    color = FEAT_INSERTION_COLOR
    bedBlocks = [BedBlock(featIndel.tStart, featIndel.tEnd)]
    yield makeBlockDeco(annotPsl, annot, annotTransRef, transCategory, featIndel.indelType, bedBlocks,
                        getIndelName(featIndel, annot), color, color,
                        dataSet, getIndelDesc(featIndel, annot))

def makeFeatIndelAnnot(featIndel, annotPsl, annot, annotTransRef, transCategory, dataSet):
    """Make glyphs or block for a particular INDEL in the annotation. A generator
    so more than one can be returned"""
    if featIndel.indelType == FeatureIndelType.insert:
        yield from makeFeatInsAnnot(featIndel, annotPsl, annot, annotTransRef, transCategory, dataSet)
    else:
        yield from makeFeatDelAnnot(featIndel, annotPsl, annot, annotTransRef, transCategory, dataSet)

def mkBrokenAnnotDecorators(transPsl, annotPsl, annot, annotTransRef, transCategory, dataSet, featIndels):
    "produces decorators to mark were annotations are broken in the mappings"
    decoratorBeds = []
    for featIndel in featIndels:
        decoratorBeds.extend(makeFeatIndelAnnot(featIndel, annotPsl, annot, annotTransRef, transCategory, dataSet))
    return decoratorBeds

def buildAnnotation(transPsl, annotPsl, annot, annotTransRef, transCategory, dataSet, decoratorBeds):
    "converts BEDs to strings so this work is distributed"
    featIndels = analyzeFeatureMapping(transPsl, annotPsl)
    bed = mkMainAnnotDecorator(annotPsl, annot, annotTransRef, transCategory, dataSet, featIndels)
    decoratorBeds.append(bed)
    if len(featIndels) > 0:
        decoratorBeds.extend(mkBrokenAnnotDecorators(transPsl, annotPsl, annot, annotTransRef, transCategory, dataSet, featIndels))

class AnnotationProcessor:
    """Class used to generate annotations.  This is used to move most of the
    processing to the pool sub-process"""

    def __init__(self, uniprotMetaTsv, uniprotAnnotsTsv, annotTransRefTsv, transGenomePsl, dataSet):
        self.dataSet = dataSet
        self.uniprotMetaTbl = UniProtMetaTbl(uniprotMetaTsv)
        self.uniprotAnnotTbl = UniProtAnnotTbl(uniprotAnnotsTsv)
        self.annotTransRefs = AnnotTransRefs(annotTransRefTsv)
        self.transGenomeAlns = GencodeDataTbl(transGenomePsl)

    def _buildAnnotation(self, annotPsl, annot, alignIdx, decoratorBeds):
        annotTransRef = self.annotTransRefs.get(annotPsl.qName, alignIdx)
        uniprotMeta = self.uniprotMetaTbl.getByAcc(annot.acc)
        transCategory = calcTransCategory(uniprotMeta, annotTransRef.transcriptId)
        transPsl = self.transGenomeAlns.getAlign(annotTransRef.transcriptId, annotPsl.tName)
        buildAnnotation(transPsl, annotPsl, annot, annotTransRef, transCategory, self.dataSet, decoratorBeds)

    def processBatch(self, alignBatch):
        decoratorBeds = []
        for annotPsl, alignIdx in alignBatch:
            annot = self.uniprotAnnotTbl.getByAnnotId(annotPsl.qName)
            if includeAnnot(annot):
                self._buildAnnotation(annotPsl, annot, alignIdx, decoratorBeds)
        return decoratorBeds

def workerInit(uniprotMetaTsv, uniprotAnnotsTsv, annotTransRefTsv, transGenomePsl, dataSet):
    "sub-process setup"
    global gAnnotationProcessor
    gAnnotationProcessor = AnnotationProcessor(uniprotMetaTsv, uniprotAnnotsTsv, annotTransRefTsv, transGenomePsl, dataSet)

def worker(alignBatch):
    "sub-process worker"
    return gAnnotationProcessor.processBatch(alignBatch)

def annotGenomeBatchReader(annotGenomePslFile, batchSize):
    """return tuples of (annotPsl, alignIdx)"""
    alignIdx = 0
    alignBatch = []

    for annotPsl in PslReader(annotGenomePslFile):
        alignBatch.append((annotPsl, alignIdx))
        alignIdx += 1
        if len(alignBatch) >= batchSize:
            yield alignBatch
            alignBatch = []
    if len(alignBatch) > 0:
        yield alignBatch

def writeDecoratorBeds(batchBedsIter, annotDecoratorBedFile):
    "write results from multiprocessing task as they come back via an iter"
    featTypes = set()
    with fileOps.AtomicFileCreate(annotDecoratorBedFile) as tmpDecoBed:
        with pipettor.Popen(["sort"] + decoratorBedSortOpts, 'w', stdout=tmpDecoBed) as decoBedFh:
            for batchBeds in batchBedsIter:
                for bed in batchBeds:
                    bed.write(decoBedFh)
                    featTypes.add((bed.category, bed.categoryName, bed.featType, bed.shortFeatType))
    return featTypes


def processSingle(uniprotMetaTsv, uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, transGenomePsl,
                  annotDecoratorBedFile, dataSet, batchSize):
    # this is easier to debug without mp
    workerInit(uniprotMetaTsv, uniprotAnnotsTsv, annotTransRefTsv, transGenomePsl, dataSet)
    batchBedsIters = []
    for alignBatch in annotGenomeBatchReader(annotGenomePslFile, batchSize):
        batchBedsIters.append(worker(alignBatch))

    featTypes = writeDecoratorBeds(batchBedsIters, annotDecoratorBedFile)
    return featTypes

def processMulti(uniprotMetaTsv, uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, transGenomePsl,
                 annotDecoratorBedFile, dataSet, nprocs, batchSize):
    with mp.Pool(processes=nprocs, initializer=workerInit,
                 initargs=(uniprotMetaTsv, uniprotAnnotsTsv, annotTransRefTsv, transGenomePsl, dataSet)) as pool:
        batchBedsIter = pool.imap_unordered(worker,
                                            annotGenomeBatchReader(annotGenomePslFile, batchSize))
        featTypes = writeDecoratorBeds(batchBedsIter, annotDecoratorBedFile)
    return featTypes

def writeFeatTypes(featTypes, featTypesTsv):
    with fileOps.opengz(featTypesTsv, 'w') as fh:
        fileOps.prRowv(fh, "category", "categoryName", "featType", "shortFeatType")
        for ft in sorted(featTypes):
            fileOps.prRowv(fh, *ft)

def uniprotAnnotsToDecorators(uniprotMetaTsv, uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, transGenomePsl,
                              annotDecoratorBedFile, dataSet, nprocs, batchSize, featTypesTsv):
    # special case one process makes profiling easier
    if nprocs == 1:
        featTypes = processSingle(uniprotMetaTsv, uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, transGenomePsl,
                                  annotDecoratorBedFile, dataSet, batchSize)
    else:
        featTypes = processMulti(uniprotMetaTsv, uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, transGenomePsl,
                                 annotDecoratorBedFile, dataSet, nprocs, batchSize)
    if featTypesTsv is not None:
        writeFeatTypes(featTypes, featTypesTsv)

def main(opts):
    uniprotAnnotsToDecorators(opts.uniprotMetaTsv, opts.uniprotAnnotsTsv, opts.annotGenomePsl, opts.annotTransRefTsv,
                              opts.transGenomePsl, opts.annotDecoratorBedFile, opts.dataset, opts.nprocs, opts.batchSize,
                              opts.featTypesTsv)

if __name__ == '__main__':
    mp.set_start_method("fork")
    main(parseArgs())
