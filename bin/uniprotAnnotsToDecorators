#!/usr/bin/env python3

import sys
import os
import os.path as osp
import argparse
import multiprocessing as mp
from collections import namedtuple
os.environ["OPENBLAS_NUM_THREADS"] = "1"
import pandas as pd
import pipettor
from pycbio.sys import fileOps
from pycbio.sys.profile import Profile
from pycbio.hgdata.psl import PslReader
from pycbio.hgdata.bed import Bed, BedBlock

sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))
from protmap.uniprot import UniprotAnnotTbl, getAnnotColor, getAnnotBedName
from protmap.gencode import GencodeData
from protmap.mappingAnalysis import analyzeFeatureMapping


def parseArgs():
    desc = """
    Convert domain annotations alignments create by uniprotMapAnnots
    to a decorator BED file in uniprotDecoration.as format.  Possibly filtering
    the results.
    """
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--nprocs", type=int, default=1,
                        help="number of processes to use for tasks")
    parser.add_argument("--batchSize", type=int, default=1000,
                        help="size of batch to sent to task")
    parser.add_argument("--trembl", action='store_true',
                        help="is this trembl?")
    parser.add_argument("transGenomePsl",
                        help="transcript genome alignment; often from genePredToPsl")
    parser.add_argument("uniprotAnnotsTsv",
                        help="Uniprot annotations TSV from uniprotToTab")
    parser.add_argument("annotGenomePsl",
                        help="Uniprot annotations mapped to genome from uniprotMapAnnots")
    parser.add_argument("annotTransRefTsv",
                        help="association of annotations to mapped transcripts")
    parser.add_argument("annotDecoratorBedFile",
                        help="annotation decorator BED file output")
    profiler = Profile(parser)
    opts = parser.parse_args()
    profiler.setup(opts)
    return opts

# threshold for generating one glyph rather than two
INDEL_SHORT_THRESHOLD = 8

class BedPlusColumns(namedtuple("BedPlusColumns",
                                ("decoratedItem", "style", "fillColor",
                                 "glyph", "uniprotAcc", "uniprotType",
                                 "shortFeatType", "featType", "shortName",
                                 "longName", "comment", "disease"))):
    "extra BED columns"
    __slots__ = ()

# shortFeatType to not use
shortFeatTypesToSkip = frozenset([
    'variant',
    'conflict',
    'splicing',
    'biased'
])

def includeAnnot(annot):
    "filter for undesired annotations"
    return annot.shortFeatType not in shortFeatTypesToSkip

def createDecoratorBed(chrom, strand, bedBlocks, annotTransRef, name, color, fillColor, style,
                       uniprotAcc, uniprotType, shortFeatType, featType, shortName, longName,
                       comment, disease, *, glyph=None, thickStart=None, thickEnd=None):
    "this determines the struct of the BED, with annotation options are supplied"
    start, end = bedBlocks[0].start, bedBlocks[-1].end
    decoratedItem = annotTransRef.transcriptPos + ':' + annotTransRef.transcriptId
    if glyph is None:
        glyph = ""
    if fillColor is None:
        fillColor = color
    if thickStart is None:
        thickStart = start
    if thickEnd is None:
        thickEnd = end
    extraCols = BedPlusColumns(decoratedItem, style, fillColor.toRgba8Str(), glyph,
                               uniprotAcc, uniprotType, shortFeatType, featType,
                               shortName, longName, comment, disease)
    return Bed(chrom, start, end, name,
               strand=strand, thickStart=thickStart, thickEnd=thickEnd,
               blocks=bedBlocks, numStdCols=12,
               itemRgb=color.toRgb8Str(),
               extraCols=extraCols)

def mkMainAnnotDecorator(annotPsl, annot, annotTransRef, isTrembl):
    color = getAnnotColor(annot, isTrembl)
    fillColor = color.setAlpha(0.5)
    uniprotType = "TreMBL" if isTrembl else "SwissProt"
    bedBlocks = [BedBlock(pb.tStart, pb.tEnd) for pb in annotPsl.blocks]
    return createDecoratorBed(annotPsl.tName, annotPsl.qStrand, bedBlocks, annotTransRef,
                              getAnnotBedName(annot), color, fillColor, "block",
                              annot.acc, uniprotType,
                              annot.shortFeatType, annot.featType, annot.shortName, annot.longName,
                              annot.comment, annot.disease)

def makeFeatIndelGlyph(featIndel, annotPsl, annot, annotTransRef, isTrembl):
    "make glyph for a particular INDEN in the annotation "
    print("@",featIndel)
    return None

def mkBrokenAnnotDecorators(transPsl, annotPsl, annot, annotTransRef, isTrembl):
    "produces glyphs to mark were annotations are broken in the mappings"
    glyphBeds = []
    for featIndel in analyzeFeatureMapping(transPsl, annotPsl):
        bed = makeFeatIndelGlyph(featIndel, annotPsl, annot, annotTransRef, isTrembl)
        if bed is not None:
            glyphBeds.append(bed)
    return glyphBeds


def buildAnnotation(transPsl, annotPsl, annot, annotTransRef, isTrembl, decoratorBeds):
    "converts BEDs to strings so this work is distributed"
    bed = mkMainAnnotDecorator(annotPsl, annot, annotTransRef, isTrembl)
    decoratorBeds.append(bed)
    glyphBeds = mkBrokenAnnotDecorators(transPsl, annotPsl, annot, annotTransRef, isTrembl)
    decoratorBeds.extend(glyphBeds)

class AnnotTransRefs:
    """look up transcript for a PSL row"""
    def __init__(self, annotTransRefTsv):
        self.df = pd.read_table(annotTransRefTsv)
        self.df.set_index('alignIdx', inplace=True, drop=False, verify_integrity=True)

    def get(self, annotId, alignIdx):
        annotTransRef = self.df[self.df.index == alignIdx].iloc[0]
        if annotId != annotTransRef.annotId:
            raise Exception(f"annotGenomePsl '{annotId}' and  annotTransRefTsv '{annotTransRef.annotId}' out-of-sync")
        return annotTransRef

class AnnotationProcessor:
    """Class used to generate annotations.  This is used to move most of the
    processing to the pool sub-process"""

    def __init__(self, transGenomePsl, uniprotAnnotsTsv, annotTransRefTsv, isTrembl):
        self.isTrembl = isTrembl
        self.transGenomeAlns = GencodeData(transGenomePsl)
        self.uniprotAnnotTbl = UniprotAnnotTbl(uniprotAnnotsTsv)
        self.annotTransRefs = AnnotTransRefs(annotTransRefTsv)

    def processBatch(self, alignBatch):
        decoratorBeds = []
        for annotPsl, alignIdx in alignBatch:
            annot = self.uniprotAnnotTbl.getByAnnotId(annotPsl.qName)
            if includeAnnot(annot):
                annotTransRef = self.annotTransRefs.get(annotPsl.qName, alignIdx)
                transPsl = self.transGenomeAlns.get(annotTransRef.transcriptId, annotPsl.tName)
                buildAnnotation(transPsl, annotPsl, annot, annotTransRef, self.isTrembl, decoratorBeds)
        return decoratorBeds

def workerInit(transGenomePsl, uniprotAnnotsTsv, annotTransRefTsv, isTrembl):
    "sub-process setup"
    global gAnnotationProcessor
    gAnnotationProcessor = AnnotationProcessor(transGenomePsl, uniprotAnnotsTsv, annotTransRefTsv, isTrembl)

def worker(alignBatch):
    "sub-process worker"
    return gAnnotationProcessor.processBatch(alignBatch)

def annotGenomeBatchReader(annotGenomePslFile, batchSize):
    """return tuples of (annotPsl, alignIdx)"""
    alignIdx = 0
    alignBatch = []

    for annotPsl in PslReader(annotGenomePslFile):
        alignBatch.append((annotPsl, alignIdx))
        alignIdx += 1
        if len(alignBatch) >= batchSize:
            yield alignBatch
            alignBatch = []
    if len(alignBatch) > 0:
        yield alignBatch

def writeDecoratorBeds(batchBedLinesIter, annotDecoratorBedFile):
    "write results from multiprocessing task as they come back via an iter"
    with fileOps.AtomicFileCreate(annotDecoratorBedFile) as tmpDecoBed:
        # also sort by target item and feature type for test reproducible
        with pipettor.Popen(["sort", "-k1,1", "-k2,2n", "-k3,3n", "-k13,13n", "-k4,4n"], 'w', stdout=tmpDecoBed) as decoBedFh:
            for batchBeds in batchBedLinesIter:
                for bed in batchBeds:
                    bed.write(decoBedFh)

def processSingle(transGenomePsl, uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, annotDecoratorBedFile,
                  isTrembl, batchSize):
    workerInit(transGenomePsl, uniprotAnnotsTsv, annotTransRefTsv, isTrembl)
    batchBedLines = []
    for alignBatch in annotGenomeBatchReader(annotGenomePslFile, batchSize):
        batchBedLines.append(worker(alignBatch))

    writeDecoratorBeds(batchBedLines, annotDecoratorBedFile)


def processMulti(transGenomePsl, uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, annotDecoratorBedFile,
                 isTrembl, nprocs, batchSize):
    with mp.Pool(processes=nprocs, initializer=workerInit,
                 initargs=(transGenomePsl, uniprotAnnotsTsv, annotTransRefTsv, isTrembl)) as pool:
        batchBedLinesIter = pool.imap_unordered(worker,
                                                annotGenomeBatchReader(annotGenomePslFile, batchSize))
        writeDecoratorBeds(batchBedLinesIter, annotDecoratorBedFile)


def uniprotAnnotsToDecorators(transGenomePsl, uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, annotDecoratorBedFile,
                              isTrembl, nprocs, batchSize):
    # special case one process makes profiling easier
    if nprocs == 1:
        processSingle(transGenomePsl, uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, annotDecoratorBedFile,
                      isTrembl, batchSize)
    else:
        processMulti(transGenomePsl, uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, annotDecoratorBedFile,
                     isTrembl, nprocs, batchSize)

def main(opts):
    uniprotAnnotsToDecorators(opts.transGenomePsl, opts.uniprotAnnotsTsv, opts.annotGenomePsl, opts.annotTransRefTsv,
                              opts.annotDecoratorBedFile, opts.trembl, opts.nprocs, opts.batchSize)

if __name__ == '__main__':
    mp.set_start_method("fork")
    main(parseArgs())
