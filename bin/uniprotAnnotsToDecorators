#!/usr/bin/env python3

import sys
import os
import os.path as osp
import argparse
import multiprocessing as mp
os.environ["OPENBLAS_NUM_THREADS"] = "1"
import pandas as pd
import pipettor
from pycbio.sys import fileOps
from pycbio.sys.color import Color
from pycbio.sys.profile import Profile
from pycbio.hgdata.psl import PslReader
from pycbio.hgdata.bed import Bed, BedBlock

sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))
from protmap.uniprot import UniprotAnnotTbl

def parseArgs():
    desc = """
    Convert domain annotations alignments create by uniprotMapAnnots
    to a decorator BED file in uniprotDecoration.as format.  Possibly filtering
    the results.
    """
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--nprocs", type=int, default=1,
                        help="number of processes to use for tasks")
    parser.add_argument("--batchSize", type=int, default=1000,
                        help="size of batch to sent to task")
    parser.add_argument("--trembl", action='store_true',
                        help="is this trembl?")
    parser.add_argument("uniprotAnnotsTsv",
                        help="Uniprot annotations TSV from uniprotToTab")
    parser.add_argument("annotGenomePsl",
                        help="Uniprot annotations mapped to genome from  uniprotMapAnnots")
    parser.add_argument("annotTransRefTsv",
                        help="association of annotations to mapped transcripts")
    parser.add_argument("annotDecoratorBedFile",
                        help="annotation decorator BED file output")
    profiler = Profile(parser)
    opts = parser.parse_args()
    profiler.setup(opts)
    return opts

###
# color logic to match uniprot track, taken from
# /hive/data/outside/otto/uniprot/doUniprot
###

# some feature types should not go into the bed name field.
# for these features, we use the 'comment' as the bed name
# e.g. "region of interest" is not very interesting, the actual
# description is usually much more interesting.
useComment = set(["domain", "chain", "region of interest", "topological domain", "short sequence motif"])

TREMBLCOLOR = Color.fromRgb8Str("0,150,250")  # light blue
SWISSPCOLOR = Color.fromRgb8Str("12,12,120")  # dark blue

# mapping of annotations columns to colors
featTypeColors = {
    "modified residue": Color.fromRgb8Str("200,200,0"),
    "glycosylation site": Color.fromRgb8Str("0,100,100"),
    "disulfide bond": Color.fromRgb8Str("100,100,100"),
    "topological domain": Color.fromRgb8Str("100,0,0"),
    "zinc finger region": Color.fromRgb8Str("100,100,0"),
    "transmembrane region": Color.fromRgb8Str("0,150,0"),  # dark green
    "signal peptide": Color.fromRgb8Str("255,0,150"),  # light-red
}
commentColor = {
    "Extracellular": Color.fromRgb8Str("0,110,180"),  # light-blue
    "Cytoplasmic": Color.fromRgb8Str("255,150,0"),  # light orange
}

def getAnnotColor(annot, isTrembl):
    if isTrembl:
        return TREMBLCOLOR
    color = commentColor.get(annot.comment, None)
    if color is None:
        color = featTypeColors.get(annot.featType, None)
    return color if color is not None else SWISSPCOLOR

# shortFeatType to not use
_shortFeatTypesToSkip = frozenset([
    'variant',
    'conflict',
    'splicing',
    'biased'
])
def includeAnnot(annot):
    "filter for undesired annotations"
    return annot.shortFeatType not in _shortFeatTypesToSkip

def createDecoratorBed(annotPsl, annotTransRef, name, color, fillColor, style,
                       uniprotAcc, uniprotType, shortFeatType, featType, shortName, longName,
                       comment, disease, *, glyph=None, thickStart=None, thickEnd=None):
    "this determines the struct of the BED, with annotation options are supplied"
    blocks = [BedBlock(pb.tStart, pb.tEnd) for pb in annotPsl.blocks]
    start, end = blocks[0].start, blocks[-1].end
    decoratedItem = annotTransRef.transcriptPos + ':' + annotTransRef.transcriptId
    if glyph is None:
        glyph = ""
    if fillColor is None:
        fillColor = color
    if thickStart is None:
        thickStart = start
    if thickEnd is None:
        thickEnd = end
    return Bed(annotPsl.tName, start, end, name,
               strand=annotPsl.qStrand, thickStart=thickStart, thickEnd=thickEnd,
               blocks=blocks, numStdCols=12,
               itemRgb=color.toRgb8Str(),
               extraCols=[decoratedItem, style, fillColor.toRgba8Str(), glyph,
                          uniprotAcc, uniprotType, shortFeatType, featType,
                          shortName, longName, comment, disease])

class AnnotTransRefs:
    """look up transcript for a PSL row"""
    def __init__(self, annotTransRefTsv):
        self.df = pd.read_table(annotTransRefTsv)
        self.df.set_index('alignIdx', inplace=True, drop=False, verify_integrity=True)

    def get(self, annotId, alignIdx):
        annotTransRef = self.df[self.df.index == alignIdx].iloc[0]
        if annotId != annotTransRef.annotId:
            raise Exception(f"annotGenomePsl '{annotId}' and  annotTransRefTsv '{annotTransRef.annotId}' out-of-sync")
        return annotTransRef

def mkMainAnnotDecorator(annotPsl, annot, annotTransRef, isTrembl):
    color = getAnnotColor(annot, isTrembl)
    fillColor = color.setAlpha(0.5)
    uniprotType = "TreMBL" if isTrembl else "SwissProt"
    return createDecoratorBed(annotPsl, annotTransRef,
                              annot.shortFeatType, color, fillColor, "block",
                              annot.acc, uniprotType,
                              annot.shortFeatType, annot.featType, annot.shortName, annot.longName,
                              annot.comment, annot.disease)

def buildAnnotation(annotPsl, annot, annotTransRef, isTrembl, decoratorBedLines):
    "converts BEDs to strings so this work is distributed"
    bed = mkMainAnnotDecorator(annotPsl, annot, annotTransRef, isTrembl)
    decoratorBedLines.append(str(bed))

class AnnotationProcessor:
    """Class used to generate annotations.  This is used to move most of the
    processing to the pool sub-process"""

    def __init__(self, uniprotAnnotsTsv, annotTransRefTsv, isTrembl):
        self.isTrembl = isTrembl
        self.uniprotAnnotTbl = UniprotAnnotTbl(uniprotAnnotsTsv)
        self.annotTransRefs = AnnotTransRefs(annotTransRefTsv)

    def processBatch(self, alignBatch):
        decoratorBedLines = []
        for annotPsl, alignIdx in alignBatch:
            annot = self.uniprotAnnotTbl.getByAnnotId(annotPsl.qName)
            if includeAnnot(annot):
                annotTransRef = self.annotTransRefs.get(annotPsl.qName, alignIdx)
                buildAnnotation(annotPsl, annot, annotTransRef, self.isTrembl, decoratorBedLines)
        return decoratorBedLines

def workerInit(uniprotAnnotsTsv, annotTransRefTsv, isTrembl):
    "sub-process setup"
    global gAnnotationProcessor
    gAnnotationProcessor = AnnotationProcessor(uniprotAnnotsTsv, annotTransRefTsv, isTrembl)

def worker(alignBatch):
    "sub-process worker"
    return gAnnotationProcessor.processBatch(alignBatch)

def annotGenomeBatchReader(annotGenomePslFile, batchSize):
    """return tuples of (annotPsl, alignIdx)"""
    alignIdx = 0
    alignBatch = []

    for annotPsl in PslReader(annotGenomePslFile):
        alignBatch.append((annotPsl, alignIdx))
        alignIdx += 1
        if len(alignBatch) >= batchSize:
            yield alignBatch
            alignBatch = []
    if len(alignBatch) > 0:
        yield alignBatch

def writeDecoratorBeds(batchBedLinesIter, annotDecoratorBedFile):
    "write results from multiprocessing task as they come back via an iter"
    with fileOps.AtomicFileCreate(annotDecoratorBedFile) as tmpDecoBed:
        # also sort by target item and feature type for test reproducible
        with pipettor.Popen(["sort", "-k1,1", "-k2,2n", "-k3,3n", "-k13,13n", "-k4,4n"], 'w', stdout=tmpDecoBed) as decoBedFh:
            for batchBeds in batchBedLinesIter:
                for bed in batchBeds:
                    print(bed, file=decoBedFh)

def processSingle(uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, annotDecoratorBedFile,
                  isTrembl, batchSize):
    workerInit(uniprotAnnotsTsv, annotTransRefTsv, isTrembl)
    batchBedLines = []
    for alignBatch in annotGenomeBatchReader(annotGenomePslFile, batchSize):
        batchBedLines.append(worker(alignBatch))

    writeDecoratorBeds(batchBedLines, annotDecoratorBedFile)


def processMulti(uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, annotDecoratorBedFile,
                 isTrembl, nprocs, batchSize):
    with mp.Pool(processes=nprocs, initializer=workerInit,
                 initargs=(uniprotAnnotsTsv, annotTransRefTsv, isTrembl)) as pool:
        batchBedLinesIter = pool.imap_unordered(worker,
                                                annotGenomeBatchReader(annotGenomePslFile, batchSize))
        writeDecoratorBeds(batchBedLinesIter, annotDecoratorBedFile)


def uniprotAnnotsToDecorators(uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, annotDecoratorBedFile,
                              isTrembl, nprocs, batchSize):
    # special case one process makes profiling easier
    if nprocs == 1:
        processSingle(uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, annotDecoratorBedFile,
                      isTrembl, batchSize)
    else:
        processMulti(uniprotAnnotsTsv, annotGenomePslFile, annotTransRefTsv, annotDecoratorBedFile,
                     isTrembl, nprocs, batchSize)

def main(opts):
    uniprotAnnotsToDecorators(opts.uniprotAnnotsTsv, opts.annotGenomePsl, opts.annotTransRefTsv,
                              opts.annotDecoratorBedFile, opts.trembl, opts.nprocs, opts.batchSize)

if __name__ == '__main__':
    mp.set_start_method("fork")
    main(parseArgs())
