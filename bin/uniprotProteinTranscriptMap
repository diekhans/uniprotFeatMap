#!/usr/bin/env python3

import sys
import os.path as osp
import argparse
import pipettor
from pycbio.sys import fileOps
from pycbio.hgdata.psl import Psl, PslReader

sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))
from uniprotmap import dropVersion
from uniprotmap.gencode import GencodeMetaTbl, GencodeDataTbl, gencodeMakeCdsPsl
from uniprotmap.uniprot import UniProtMetaTbl, dropUniportIsoformModifier

# Terminology
#    xxxId is id with version
#    xxxAcc is id without version
#
# Algorithm:
#   - Start with alignments of UniProt proteins that match the UniProt canonical
#     GENCODE coding transcripts.  These are already filtered for ++ strand
#     and maximal coverage of protein.
#   - If multiple alignments to a canonical transcript, pick best one.
#   - Project the canonical transcript alignments to non-canonical transcript isoforms.
#     Using the genome This doesn't consider gene, which allows project to read-through transcripts.
#     Only CDS on other isoforms will have proteins mapped to it by masking the
#     UTR unaligned to the genome.

def parseArgs():
    desc = """Filter protein to PSL transcript alignments to pair them based
    on being the listed transcript in UniProt.  Project the primary alignments
    to other transcript isoforms using the genomic coordinates. Output alignments
    in CDS coordinates rather than AA. """

    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--interPrefix",
                        help="""save the intermediate files to names starting ${iterPrefix}.${name}.psl  ${iterPrefix}.name.type""")
    parser.add_argument("gencodeMetaTsv",
                        help="GENCODE metadata in TSV format UCSC import (not table), which includes tags")
    parser.add_argument("gencodeGp",
                        help="GENCODE annotations in GenePred format")
    parser.add_argument("gencodePsl",
                        help="GENCODE annotations in PSL format")
    parser.add_argument("uniprotMetaTsv",
                        help="Uniprot metadata in TSV format")
    parser.add_argument("protTransPsl",
                        help="protein to transcript alignment PSL")
    parser.add_argument("cdsTransPsl",
                        help="filtered alignments, in CDS coordinates")
    parser.add_argument("problemLogTsv",
                        help="log file of issues that happened")
    return parser.parse_args()

##
# data loading and filtering
##
def keepCanonicalProtMRnaAlign(uniprotMetaTbl, psl):
    """Only keep alignments from canonical SwissProt isoform, as alt-isoforms to
    a canonical transcript"""
    uniprotMeta = uniprotMetaTbl.getByAcc(dropUniportIsoformModifier(psl.qName))
    return ((psl.qName == uniprotMeta.mainIsoAcc) and uniprotMeta.isCanonProtTrans(psl.tName))

def saveBestCanonAlign(alignsByProtTrans, psl):
    key = (psl.qName, psl.tName)
    curPsl = alignsByProtTrans.get(key)
    if (curPsl is None) or (psl.queryAligned() > curPsl.queryAligned()):
        alignsByProtTrans[key] = psl  # first of better

def loadFitlerCdsToTransPsl(uniprotMetaTbl, protTransPslFile):
    """load aligned PSL, converting them to CDS->NA PSL, filter to keep the
    best canonical transcript.  """
    alignsByProtTrans = {}
    with pipettor.Popen(["pslProtToRnaCoords", protTransPslFile, "/dev/stdout"]) as fh:
        for psl in PslReader(fh):
            if keepCanonicalProtMRnaAlign(uniprotMetaTbl, psl):
                saveBestCanonAlign(alignsByProtTrans, psl)
    return list(alignsByProtTrans.values())

def writePsls(psls, pslFile):
    with fileOps.opengz(pslFile, 'w') as pslFh:
        for psl in sorted(psls, key=Psl.targetKey):
            psl.write(pslFh)

###
# Project alignments from UniProt canonical transcripts to transcripts isoforms
# that are non-canonical UniProt.
###
def writeCanonCdsToTransAligns(canonCdsToTransAligns):
    canonCdsToTransPslFile = fileOps.tmpFileGet("canon-cds-trans", suffix=".psl")
    writePsls(canonCdsToTransAligns, canonCdsToTransPslFile)
    return canonCdsToTransPslFile

def writeCanonTransToGenomeAligns(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl):
    canonTransToGenomePslFile = fileOps.tmpFileGet("canon-trans-genome", suffix=".psl")
    with open(canonTransToGenomePslFile, 'w') as pslFh:
        for transId in sorted(gencodeMetaTbl.codingTransIds):
            if uniprotMetaTbl.isCanonProtTrans(transId):
                for entry in gencodeDataTbl.getEntries(transId):
                    entry.alignPsl.write(pslFh)
    return canonTransToGenomePslFile

def writeNoncanonTransToGenome(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl):
    "this will make UTR portions unaligned"
    noncanonTransToGenomePslFile = fileOps.tmpFileGet("noncanon-trans-genome", suffix=".psl")
    with open(noncanonTransToGenomePslFile, 'w') as pslFh:
        for transcriptId in sorted(gencodeMetaTbl.codingTransIds):
            if not uniprotMetaTbl.isCanonProtTrans(transcriptId):
                for entry in gencodeDataTbl.getEntries(transcriptId):
                    gencodeMakeCdsPsl(entry.annotGp, entry.alignPsl).write(pslFh)
    return noncanonTransToGenomePslFile

def mkPslMapCmds(inPsl, mapPsl, outPsl, swapMap=False, interPrefix=None):
    cmd1 = ["pslMap", "-check", "-inType=na_na", "-mapType=na_na"]
    cmds = [cmd1]
    if swapMap:
        cmd1.append("-swapMap")
    if interPrefix is not None:
        cmd1.append(f"-mapInfo={interPrefix}.mapInfo.tsv")
    cmd1.extend((inPsl, mapPsl, outPsl))
    if interPrefix is not None:
        cmd2 = ["tee", f"{interPrefix}.psl"]
        cmds.append(cmd2)
    return cmds

def readFilterMapped(inFh, rawPslFh):
    alignsByProtTrans = {}
    for psl in PslReader(inFh):
        saveBestCanonAlign(alignsByProtTrans, psl)
        if rawPslFh is not None:
            psl.write(rawPslFh)
    return alignsByProtTrans

def mapCanonicalToNoncanon(canonCdsToTransPslFile, canonTransToGenomePslFile, noncanonTransToGenomePslFile, interPrefix):
    if interPrefix is not None:
        canonToGennomeInter = f"{interPrefix}canonToGenome"
        canonToNoncanonInter = f"{interPrefix}canonToNoncanon"
    else:
        canonToGennomeInter = canonToNoncanonInter = None

    cmds = (mkPslMapCmds(canonCdsToTransPslFile, canonTransToGenomePslFile, "/dev/stdout",
                         interPrefix=canonToGennomeInter) +
            mkPslMapCmds("/dev/stdin", noncanonTransToGenomePslFile, "/dev/stdout", swapMap=True,
                         interPrefix=canonToNoncanonInter))

    # will get multiple alignments for multiple canon alignments, keep ones with best coverage
    rawPslFh = open(f"{interPrefix}canonToNoncanon.raw.psl", 'w') if interPrefix is not None else None
    with pipettor.Popen(cmds) as inFh:
        alignsByProtTrans = readFilterMapped(inFh, rawPslFh)
    if rawPslFh is not None:
        rawPslFh.close()
    return list(alignsByProtTrans.values())

def projectUniPortAlignments(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl, canonCdsToTransAligns, interPrefix):
    # mapping pipeline is:
    #   portCds->canonTrans => canonTrans->genome => genome->isoTransCds => protCds->isoTrans
    # converted to CDS alignments to allow mapping to work.
    # isoFormGen

    canonCdsToTransPslFile = writeCanonCdsToTransAligns(canonCdsToTransAligns)
    canonTransToGenomePslFile = writeCanonTransToGenomeAligns(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl)
    noncanonTransToGenomePslFile = writeNoncanonTransToGenome(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl)
    noncanonCdsToTransAligns = mapCanonicalToNoncanon(canonCdsToTransPslFile, canonTransToGenomePslFile, noncanonTransToGenomePslFile, interPrefix)

    fileOps.rmFiles(canonCdsToTransPslFile, canonTransToGenomePslFile, noncanonTransToGenomePslFile)
    return noncanonCdsToTransAligns

##
# output
##
def _getQNameSet(aligns):
    return frozenset([dropVersion(psl.qName) for psl in aligns])

def _getTNameSet(aligns):
    return frozenset([dropVersion(psl.tName) for psl in aligns])

def problemLog(logFh, reason, geneId=None, transcriptId=None, transcriptType=None, uniprotId=None):
    fileOps.prRowv(logFh, reason, geneId, transcriptId, transcriptType, uniprotId)

def reportUnalignedUniprots(uniprotMetaTbl, canonCdsToTransAligns, logFh):
    alignedUniprotIds = _getQNameSet(canonCdsToTransAligns)
    unalignedUniprotIds = frozenset(uniprotMetaTbl.byMainIsoAcc.keys()) - alignedUniprotIds
    for uniprotId in sorted(unalignedUniprotIds):
        problemLog(logFh, "uniprot_not_aligned", uniprotId=uniprotId)

def _reportUnmappedTranscript(gencodeMetaTbl, uniprotMetaTbl, unmappedTransAccs, reason, transAcc, logFh):
    transRec = gencodeMetaTbl.byTranscriptAcc.get(transAcc)
    geneId = transId = None
    if transRec is not None:
        geneId = transRec.geneId
        transId = transRec.transcriptId
    uniprotMetas = uniprotMetaTbl.byTranscriptAcc.get(transAcc)
    if transId is None:
        problemLog(logFh, "transcript_not_in_gene_set", transAcc, None, uniprotMetas[0].mainIsoAcc)
    elif uniprotMetas is None:
        problemLog(logFh, reason, geneId, transId, gencodeMetaTbl.getTransType(transId), None)
    else:
        for uniprotMeta in uniprotMetas:
            problemLog(logFh, reason, geneId, transId, gencodeMetaTbl.getTransType(transId), uniprotMeta.mainIsoAcc)

def _reportUnmappedTranscripts(gencodeMetaTbl, uniprotMetaTbl, unmappedTransAccs, reason, logFh):
    for transAcc in sorted(unmappedTransAccs):
        _reportUnmappedTranscript(gencodeMetaTbl, uniprotMetaTbl, unmappedTransAccs, reason, transAcc, logFh)

def reportUnpairedCanonTrans(gencodeMetaTbl, uniprotMetaTbl, canonCdsTransAligns, logFh):
    alignedTransAccs = _getTNameSet(canonCdsTransAligns)
    unmappedTransAccs = uniprotMetaTbl.getCanonEnsemblAccSet() - alignedTransAccs

    _reportUnmappedTranscripts(gencodeMetaTbl, uniprotMetaTbl, unmappedTransAccs, "canon_trans_not_mapped", logFh)

def reportUnpairedNoncanonTrans(gencodeMetaTbl, uniprotMetaTbl, noncanonCdsToTransAligns, logFh):
    noncanonTransAccs = gencodeMetaTbl.getCodingTransAccSet() - uniprotMetaTbl.getCanonEnsemblAccSet()
    alignedTransAccs = _getTNameSet(noncanonCdsToTransAligns)
    unmappedTransAccs = noncanonTransAccs - alignedTransAccs
    _reportUnmappedTranscripts(gencodeMetaTbl, uniprotMetaTbl, unmappedTransAccs, "noncanon_trans_not_mapped", logFh)

def report(gencodeMetaTbl, uniprotMetaTbl, canonCdsToTransAligns, noncanonCdsToTransAligns, problemLogTsv):
    logFh = fileOps.opengz(problemLogTsv, 'w')
    problemLog(logFh, "reason", "geneId", "transcriptId", "transcriptType", "uniprotId")
    reportUnalignedUniprots(uniprotMetaTbl, canonCdsToTransAligns, logFh)
    reportUnpairedCanonTrans(gencodeMetaTbl, uniprotMetaTbl, canonCdsToTransAligns, logFh)
    reportUnpairedNoncanonTrans(gencodeMetaTbl, uniprotMetaTbl, noncanonCdsToTransAligns, logFh)
    logFh.close()

def proteinTranscriptAlign(gencodeMetaTsv, gencodeGpFile, gencodePslFile, uniprotMetaTsv, protTransPslFile,
                           cdsTransPslFile, problemLogTsv, interPrefix):
    gencodeMetaTbl = GencodeMetaTbl(gencodeMetaTsv)
    gencodeDataTbl = GencodeDataTbl(gencodePslFile, gencodeGpFile)
    uniprotMetaTbl = UniProtMetaTbl(uniprotMetaTsv)

    canonCdsToTransAligns = loadFitlerCdsToTransPsl(uniprotMetaTbl, protTransPslFile)
    noncanonCdsToTransAligns = projectUniPortAlignments(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl,
                                                        canonCdsToTransAligns, interPrefix)

    report(gencodeMetaTbl, uniprotMetaTbl, canonCdsToTransAligns, noncanonCdsToTransAligns, problemLogTsv)

    writePsls(canonCdsToTransAligns + noncanonCdsToTransAligns, cdsTransPslFile)

def main(opts):
    proteinTranscriptAlign(opts.gencodeMetaTsv, opts.gencodeGp, opts.gencodePsl,
                           opts.uniprotMetaTsv, opts.protTransPsl, opts.cdsTransPsl,
                           opts.problemLogTsv, opts.interPrefix)

main(parseArgs())
