#!/usr/bin/env python3

import sys
import os.path as osp
import argparse
import pipettor
from pycbio.sys import fileOps
from pycbio.hgdata.psl import Psl, PslBlock, PslReader

sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))
from uniprotmap import dropVersion
from uniprotmap.gencode import GencodeMetaTbl, GencodeDataTbl
from uniprotmap.uniprot import UniProtMetaTbl, dropUniportIsoformModifier

# Terminology
#    xxxId is id with version
#    xxxAcc is id without version
#
# Algorithm:
#   - Start with alignments of UniProt proteins that match the UniProt canonical
#     GENCODE coding transcripts.  These are already filtered for ++ strand
#     and maximal coverage of protein.
#   - If multiple alignments to a canonical transcript, pick best one.
#   - Project the canonical transcript alignments to non-canonical transcript isoforms.
#     Using the genome This doesn't consider gene, which allows project to read-through transcripts.
#     Only CDS on other isoforms will have proteins mapped to it by masking the
#     UTR unaligned to the genome.

def parseArgs():
    desc = """Filter protein to PSL transcript alignments to pair them based
    on being the listed transcript in UniProt.  Project the primary alignments
    to other transcript isoforms using the genomic coordinates. Output alignments
    in CDS coordinates rather than AA. """

    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--interPrefix",
                        help="""save the intermediate files to names starting ${iterPrefix}.${name}.psl  ${iterPrefix}.name.type""")
    parser.add_argument("gencodeMetaTsv",
                        help="GENCODE metadata in TSV format UCSC import (not table), which includes tags")
    parser.add_argument("gencodeGp",
                        help="GENCODE annotations in GenePred format")
    parser.add_argument("gencodePsl",
                        help="GENCODE annotations in PSL format")
    parser.add_argument("uniprotMetaTsv",
                        help="Uniprot metadata in TSV format")
    parser.add_argument("protTransPsl",
                        help="protein to transcript alignment PSL")
    parser.add_argument("cdsTransPsl",
                        help="filtered alignments, in CDS coordinates")
    parser.add_argument("problemLogTsv",
                        help="log file of issues that happened")
    return parser.parse_args()

##
# data loading and filtering
##
def keepCanonicalProtMRnaAlign(uniprotMetaTbl, psl):
    """Only keep alignments from canonical SwissProt isoform, as alt-isoforms to
    a canonical transcript"""
    uniprotMeta = uniprotMetaTbl.getByAcc(dropUniportIsoformModifier(psl.qName))
    return ((psl.qName == uniprotMeta.mainIsoAcc) and uniprotMeta.isCanonProtTrans(psl.tName))

def saveBestCanonAlign(alignsByProtTrans, psl):
    key = (psl.qName, psl.tName)
    curPsl = alignsByProtTrans.get(key)
    if (curPsl is None) or (psl.queryAligned() > curPsl.queryAligned()):
        alignsByProtTrans[key] = psl  # first of better

def loadFitlerCdsToTransPsl(uniprotMetaTbl, protTransPslFile):
    """load aligned PSL, converting them to CDS->NA PSL, filter to keep the
    best canonical transcript.  """
    alignsByProtTrans = {}
    with pipettor.Popen(["pslProtToRnaCoords", protTransPslFile, "/dev/stdout"]) as fh:
        for psl in PslReader(fh):
            if keepCanonicalProtMRnaAlign(uniprotMetaTbl, psl):
                saveBestCanonAlign(alignsByProtTrans, psl)
    return list(alignsByProtTrans.values())

def writePsls(psls, pslFile):
    with fileOps.opengz(pslFile, 'w') as pslFh:
        for psl in sorted(psls, key=Psl.targetKey):
            psl.write(pslFh)

##
# build PSL with UTR unaligned
##
def _makeCdsPslBlock(gp, blk):
    tStart = max(gp.cdsStart, blk.tStart)
    size = min(gp.cdsEnd, blk.tEnd) - tStart
    if size <= 0:
        return None
    qStart = blk.qStart + (tStart - blk.tStart)
    return PslBlock(qStart, tStart, size)

def _addCdsPslBlocks(gp, psl, cdsPsl):
    for blk in psl.blocks:
        cdsBlk = _makeCdsPslBlock(gp, blk)
        if cdsBlk is not None:
            cdsPsl.addBlock(cdsBlk)

def buildCdsPsl(gp, psl):
    "modify a transcript PSL to make the UTR unaligned, returning a new PSL"
    cdsPsl = Psl.create(qName=psl.qName, qSize=psl.qSize,
                        tName=psl.tName, tSize=psl.tSize,
                        strand=psl.strand)
    _addCdsPslBlocks(gp, psl, cdsPsl)

    cdsPsl.updateBounds()
    cdsPsl.updateCounts()
    return cdsPsl

###
# Project alignments from UniProt canonical transcripts to transcripts isoforms
# that are non-canonical UniProt.
###
def writeCanonCdsToTransAligns(canonCdsToTransAligns):
    canonCdsToTransPslFile = fileOps.tmpFileGet("canon-cds-trans", suffix=".psl")
    writePsls(canonCdsToTransAligns, canonCdsToTransPslFile)
    return canonCdsToTransPslFile

def writeCanonTransToGenomeAligns(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl):
    canonTransToGenomePslFile = fileOps.tmpFileGet("canon-trans-genome", suffix=".psl")
    with open(canonTransToGenomePslFile, 'w') as pslFh:
        for transId in sorted(gencodeMetaTbl.codingTransIds):
            if uniprotMetaTbl.isCanonProtTrans(transId):
                for entry in gencodeDataTbl.getEntries(transId):
                    entry.alignPsl.write(pslFh)
    return canonTransToGenomePslFile

def writeNoncanonTransToGenome(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl):
    "this will make UTR portions unaligned"
    noncanonTransToGenomePslFile = fileOps.tmpFileGet("noncanon-trans-genome", suffix=".psl")
    with open(noncanonTransToGenomePslFile, 'w') as pslFh:
        for transcriptId in sorted(gencodeMetaTbl.codingTransIds):
            if not uniprotMetaTbl.isCanonProtTrans(transcriptId):
                for entry in gencodeDataTbl.getEntries(transcriptId):
                    buildCdsPsl(entry.annotGp, entry.alignPsl).write(pslFh)
    return noncanonTransToGenomePslFile

def mkPslMapCmds(inPsl, mapPsl, outPsl, swapMap=False, interPrefix=None):
    cmd1 = ["pslMap", "-check", "-inType=na_na", "-mapType=na_na"]
    cmds = [cmd1]
    if swapMap:
        cmd1.append("-swapMap")
    if interPrefix is not None:
        cmd1.append(f"-mapInfo={interPrefix}.mapInfo.tsv")
    cmd1.extend((inPsl, mapPsl, outPsl))
    if interPrefix is not None:
        cmd2 = ["tee", f"{interPrefix}.psl"]
        cmds.append(cmd2)
    return cmds

def readFilterMapped(inFh, rawPslFh):
    alignsByProtTrans = {}
    for psl in PslReader(inFh):
        saveBestCanonAlign(alignsByProtTrans, psl)
        if rawPslFh is not None:
            psl.write(rawPslFh)
    return alignsByProtTrans

def mapCanonicalToNoncanon(canonCdsToTransPslFile, canonTransToGenomePslFile, noncanonTransToGenomePslFile, interPrefix):
    if interPrefix is not None:
        canonToGennomeInter = f"{interPrefix}canonToGenome"
        canonToNoncanonInter = f"{interPrefix}canonToNoncanon"
    else:
        canonToGennomeInter = canonToNoncanonInter = None

    cmds = (mkPslMapCmds(canonCdsToTransPslFile, canonTransToGenomePslFile, "/dev/stdout",
                         interPrefix=canonToGennomeInter) +
            mkPslMapCmds("/dev/stdin", noncanonTransToGenomePslFile, "/dev/stdout", swapMap=True,
                         interPrefix=canonToNoncanonInter))

    # will get multiple alignments for multiple canon alignments, keep ones with best coverage
    rawPslFh = open(f"{interPrefix}canonToNoncanon.raw.psl", 'w') if interPrefix is not None else None
    with pipettor.Popen(cmds) as inFh:
        alignsByProtTrans = readFilterMapped(inFh, rawPslFh)
    if rawPslFh is not None:
        rawPslFh.close()
    return list(alignsByProtTrans.values())

def projectUniPortAlignments(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl, canonCdsToTransAligns, interPrefix):
    # mapping pipeline is:
    #   portCds->canonTrans => canonTrans->genome => genome->isoTransCds => protCds->isoTrans
    # converted to CDS alignments to allow mapping to work.
    # isoFormGen

    canonCdsToTransPslFile = writeCanonCdsToTransAligns(canonCdsToTransAligns)
    canonTransToGenomePslFile = writeCanonTransToGenomeAligns(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl)
    noncanonTransToGenomePslFile = writeNoncanonTransToGenome(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl)
    noncanonCdsToTransAligns = mapCanonicalToNoncanon(canonCdsToTransPslFile, canonTransToGenomePslFile, noncanonTransToGenomePslFile, interPrefix)

    fileOps.rmFiles(canonCdsToTransPslFile, canonTransToGenomePslFile, noncanonTransToGenomePslFile)
    return noncanonCdsToTransAligns

##
# output
##
def getQNameAccSet(aligns):
    return frozenset([dropVersion(psl.qName) for psl in aligns])

def getTNameAccSet(aligns):
    return frozenset([dropVersion(psl.tName) for psl in aligns])

def problemLog(logFh, reason, uniprotId=None, geneId=None, transcriptId=None, transcriptType=None):
    fileOps.prRowv(logFh, reason, uniprotId, geneId, transcriptId, transcriptType)

def reportMissingTrans(gencodeMetaTbl, uniprotMeta, logFh):
    "none of the transcripts are in the gene set"
    if len(uniprotMeta.ensemblAccs & gencodeMetaTbl.codingGeneAccs) == 0:
        reason = "no_gene_transcript_in_geneset"
    else:
        reason = "no_transcript_in_geneset"
    problemLog(logFh, reason, uniprotId=uniprotMeta.acc,
               geneId=uniprotMeta.ensemblGene, transcriptId=uniprotMeta.ensemblTrans)

def reportUniproiNotAligned(gencodeMetaTbl, uniprotMeta, alignedUniprotIds, logFh):
    # find associated transcript info
    transRecs = [gencodeMetaTbl.byTranscriptAcc[transAcc]
                 for transAcc in uniprotMeta.ensemblTransAccs
                 if transAcc in gencodeMetaTbl.byTranscriptAcc]
    if len(transRecs) == 0:
        problemLog(logFh, "uniprot_not_aligned", uniprotId=uniprotMeta.acc)
    else:
        for transRec in transRecs:
            problemLog(logFh, "uniprot_not_aligned", uniprotId=uniprotMeta.acc,
                       geneId=transRec.geneId, transcriptId=transRec.transcriptId, transcriptType=transRec.transcriptType)


def reportUnalignedUniprot(gencodeMetaTbl, uniprotMeta, alignedUniprotIds, logFh):
    # explain why
    if len(uniprotMeta.ensemblTransIds) == 0:
        pass  # no transcripts, don't report
    elif len(uniprotMeta.ensemblTransAccs & gencodeMetaTbl.codingTransAccs) == 0:
        # report because none of the transcripts were mapped
        reportMissingTrans(gencodeMetaTbl, uniprotMeta, logFh)
    else:
        reportUniproiNotAligned(gencodeMetaTbl, uniprotMeta, alignedUniprotIds, logFh)

def reportUnalignedUniprots(gencodeMetaTbl, uniprotMetaTbl, canonCdsToTransAligns, logFh):
    alignedUniprotIds = getQNameAccSet(canonCdsToTransAligns)
    unalignedUniprotIds = frozenset(uniprotMetaTbl.byMainIsoAcc.keys()) - alignedUniprotIds
    for uniprotId in sorted(unalignedUniprotIds):
        reportUnalignedUniprot(gencodeMetaTbl, uniprotMetaTbl.getByMainIsoAcc(uniprotId), alignedUniprotIds, logFh)

def reportUnpairedNoncanonTrans(gencodeMetaTbl, uniprotMetaTbl, transAcc, logFh):
    # ones without uniprot are skipped
    transRec = gencodeMetaTbl.byTranscriptAcc.get(transAcc)
    for uniprotMeta in uniprotMetaTbl.getGeneAccMetas(dropVersion(transRec.geneId)):
        problemLog(logFh, "noncanon_trans_not_mapped", uniprotId=uniprotMeta.acc, geneId=transRec.geneId,
                   transcriptId=transRec.transcriptId, transcriptType=transRec.transcriptType)

def reportUnpairedNoncanonTranses(gencodeMetaTbl, uniprotMetaTbl, noncanonCdsToTransAligns, logFh):
    noncanonTransAccs = gencodeMetaTbl.getCodingTransAccSet() - uniprotMetaTbl.getCanonEnsemblAccSet()
    alignedTransAccs = getTNameAccSet(noncanonCdsToTransAligns)
    unmappedTransAccs = noncanonTransAccs - alignedTransAccs
    for transAcc in sorted(unmappedTransAccs):
        reportUnpairedNoncanonTrans(gencodeMetaTbl, uniprotMetaTbl, transAcc, logFh)

def report(gencodeMetaTbl, uniprotMetaTbl, canonCdsToTransAligns, noncanonCdsToTransAligns, problemLogTsv):
    with fileOps.opengz(problemLogTsv, 'w') as logFh:
        problemLog(logFh, "reason", "uniprotId", "geneId", "transcriptId", "transcriptType")
        reportUnalignedUniprots(gencodeMetaTbl, uniprotMetaTbl, canonCdsToTransAligns, logFh)
        reportUnpairedNoncanonTranses(gencodeMetaTbl, uniprotMetaTbl, noncanonCdsToTransAligns, logFh)

def proteinTranscriptAlign(gencodeMetaTsv, gencodeGpFile, gencodePslFile, uniprotMetaTsv, protTransPslFile,
                           cdsTransPslFile, problemLogTsv, interPrefix):
    gencodeMetaTbl = GencodeMetaTbl(gencodeMetaTsv)
    gencodeDataTbl = GencodeDataTbl(gencodePslFile, gencodeGpFile)
    uniprotMetaTbl = UniProtMetaTbl(uniprotMetaTsv)

    canonCdsToTransAligns = loadFitlerCdsToTransPsl(uniprotMetaTbl, protTransPslFile)
    noncanonCdsToTransAligns = projectUniPortAlignments(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl,
                                                        canonCdsToTransAligns, interPrefix)

    report(gencodeMetaTbl, uniprotMetaTbl, canonCdsToTransAligns, noncanonCdsToTransAligns, problemLogTsv)

    writePsls(canonCdsToTransAligns + noncanonCdsToTransAligns, cdsTransPslFile)

def main(opts):
    proteinTranscriptAlign(opts.gencodeMetaTsv, opts.gencodeGp, opts.gencodePsl,
                           opts.uniprotMetaTsv, opts.protTransPsl, opts.cdsTransPsl,
                           opts.problemLogTsv, opts.interPrefix)

main(parseArgs())
