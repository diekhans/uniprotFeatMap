#!/usr/bin/env python3

import sys
import os.path as osp
import argparse
import pipettor
from pycbio.sys import fileOps
from pycbio.hgdata.psl import Psl, PslReader

sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))
from protmap import dropVersion
from protmap.gencode import GencodeMetaTbl, GencodeDataTbl, gencodeMakeCdsPsl
from protmap.uniprot import UniProtMetaTbl, dropUniportIsoformModifier

# Terminology
#    xxxId is id with version
#    xxxAcc is id without version
#
# Algorithm:
#   - Start with alignments of uniprot proteins to match (list in metadats)
#     GENCODE coding transcripts.  These are already filtered for ++ strand
#     and minimal coverage of protein.
#   - If multiple alignments to a matched transcript, pick best one.
#   - Project the matched alignments to other transcript isoforms.  This
#     doesn't consider gene, which allows project to read-through transcripts.
#     Only CDS on other isoforms will have proteins mapped to it by making the
#     UTR unaligned to the genome.

def parseArgs():
    desc = """Filter protein to PSL transcript alignments to pair them based
    on being the listed transcript in UniProt.  Project the primary alignments
    to other transcript isoforms using the genomic coordinates. Output alignments
    in CDS coordinates rather than AA. """

    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--interPrefix",
                        help="""save the intermediate files to names starting ${iterPrefix}.${name}.psl  ${iterPrefix}.name.type""")
    parser.add_argument("gencodeMetaTsv",
                        help="GENCODE metadata in TSV format UCSC import (not table), which includes tags")
    parser.add_argument("gencodeGp",
                        help="GENCODE annotations in GenePred format")
    parser.add_argument("gencodePsl",
                        help="GENCODE annotations in PSL format")
    parser.add_argument("uniprotMetaTsv",
                        help="Uniprot metadata in TSV format")
    parser.add_argument("protTransPsl",
                        help="protein to transcript alignment PSL")
    parser.add_argument("cdsTransPsl",
                        help="filtered alignments, in CDS coordinates")
    parser.add_argument("problemLogTsv",
                        help="log file of issues that happened")
    return parser.parse_args()

##
# data loading and filtering
##
def isMatchedProtTrans(uniprotMeta, transId):
    "does this UniProt reference this transcript?"
    return dropVersion(transId) in uniprotMeta.ensemblTransAccs

def isReferencesdTrans(uniprotMetaTbl, transId):
    "does any UniProt reference this transcript?"
    return dropVersion(transId) in uniprotMetaTbl.byTranscriptAcc

def keepCanonicalProtMRnaAlign(uniprotMetaTbl, psl):
    """Only keep alignments from canonical SwissProt isoform, as alt-isoforms to
    a matched transcript"""
    uniprotMeta = uniprotMetaTbl.getByAcc(dropUniportIsoformModifier(psl.qName))
    return ((psl.qName == uniprotMeta.mainIsoAcc) and isMatchedProtTrans(uniprotMeta, psl.tName))

def saveBestMatchedAlign(alignsByProtTrans, psl):
    key = (psl.qName, psl.tName)
    curPsl = alignsByProtTrans.get(key)
    if (curPsl is None) or (psl.queryAligned() > curPsl.queryAligned()):
        alignsByProtTrans[key] = psl  # first of better

def loadFitlerCdsToTransPsl(uniprotMetaTbl, protTransPslFile):
    """load aligned PSL, converting them to CDS->NA PSL, filter to keep the best matched transcript.
    """
    alignsByProtTrans = {}
    with pipettor.Popen(["pslProtToRnaCoords", protTransPslFile, "/dev/stdout"]) as fh:
        for psl in PslReader(fh):
            if keepCanonicalProtMRnaAlign(uniprotMetaTbl, psl):
                saveBestMatchedAlign(alignsByProtTrans, psl)
    return list(alignsByProtTrans.values())

def writePsls(psls, pslFile):
    with fileOps.opengz(pslFile, 'w') as pslFh:
        for psl in sorted(psls, key=Psl.targetKey):
            psl.write(pslFh)

###
# Project alignments from UniProt matched transcripts to transcripts isoforms
# that are not matched UniProt.
###
def writeMatchedCdsToTransAligns(matchedCdsToTransAligns):
    matchedCdsToTransPslFile = fileOps.tmpFileGet("matched-cds-trans", suffix=".psl")
    writePsls(matchedCdsToTransAligns, matchedCdsToTransPslFile)
    return matchedCdsToTransPslFile

def writeMatchedTransToGenomeAligns(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl):
    matchTransToGenomePslFile = fileOps.tmpFileGet("matched-trans-genome", suffix=".psl")
    with open(matchTransToGenomePslFile, 'w') as pslFh:
        for transId in sorted(gencodeMetaTbl.codingTransIds):
            if isReferencesdTrans(uniprotMetaTbl, transId):
                for entry in gencodeDataTbl.getEntries(transId):
                    entry.alignPsl.write(pslFh)
    return matchTransToGenomePslFile

def writeUnmatchedTransToGenome(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl):
    "this will make UTR portions unaligned"
    unmatchedTransToGenomePslFile = fileOps.tmpFileGet("unmatched-trans-genome", suffix=".psl")
    with open(unmatchedTransToGenomePslFile, 'w') as pslFh:
        for transcriptId in sorted(gencodeMetaTbl.codingTransIds):
            if not isReferencesdTrans(uniprotMetaTbl, transcriptId):
                for entry in gencodeDataTbl.getEntries(transcriptId):
                    gencodeMakeCdsPsl(entry.annotGp, entry.alignPsl).write(pslFh)
    return unmatchedTransToGenomePslFile

def mkPslMapCmds(inPsl, mapPsl, outPsl, swapMap=False, interPrefix=None):
    cmd1 = ["pslMap", "-check", "-inType=na_na", "-mapType=na_na"]
    cmds = [cmd1]
    if swapMap:
        cmd1.append("-swapMap")
    if interPrefix is not None:
        cmd1.append(f"-mapInfo={interPrefix}.mapInfo.tsv")
    cmd1.extend((inPsl, mapPsl, outPsl))
    if interPrefix is not None:
        cmd2 = ["tee", f"{interPrefix}.psl"]
        cmds.append(cmd2)
    return cmds

def readFilterMapped(inFh, rawPslFh):
    alignsByProtTrans = {}
    for psl in PslReader(inFh):
        saveBestMatchedAlign(alignsByProtTrans, psl)
        if rawPslFh is not None:
            psl.write(rawPslFh)
    return alignsByProtTrans

def mapCanonicalToUnmatched(matchedCdsToTransPslFile, matchedTransToGenomePslFile, unmatchedTransToGenomePslFile, interPrefix):
    if interPrefix is not None:
        matchedToGennomeInter = f"{interPrefix}matchedToGenome"
        matchedToUnmatchedInter = f"{interPrefix}matchedToUnmatched"
    else:
        matchedToGennomeInter = matchedToUnmatchedInter = None

    cmds = (mkPslMapCmds(matchedCdsToTransPslFile, matchedTransToGenomePslFile, "/dev/stdout",
                         interPrefix=matchedToGennomeInter) +
            mkPslMapCmds("/dev/stdin", unmatchedTransToGenomePslFile, "/dev/stdout", swapMap=True,
                         interPrefix=matchedToUnmatchedInter))

    # will get multiple alignments for multiple matched alignments, keep ones with best coverage
    rawPslFh = open(f"{interPrefix}matchedToUnmatched.raw.psl", 'w') if interPrefix is not None else None
    with pipettor.Popen(cmds) as inFh:
        alignsByProtTrans = readFilterMapped(inFh, rawPslFh)
    if rawPslFh is not None:
        rawPslFh.close()
    return list(alignsByProtTrans.values())

def projectUniPortAlignments(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl, matchedCdsToTransAligns, interPrefix):
    # mapping pipeline is:
    #   portCds->matchTrans => matchTrans->genome => genome->isoTransCds => protCds->isoTrans
    # converted to CDS alignments to allow mapping to work.
    # isoFormGen

    matchedCdsToTransPslFile = writeMatchedCdsToTransAligns(matchedCdsToTransAligns)
    matchedTransToGenomePslFile = writeMatchedTransToGenomeAligns(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl)
    unmatchedTransToGenomePslFile = writeUnmatchedTransToGenome(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl)
    unmatchedCdsToTransAligns = mapCanonicalToUnmatched(matchedCdsToTransPslFile, matchedTransToGenomePslFile, unmatchedTransToGenomePslFile, interPrefix)

    fileOps.rmFiles(matchedCdsToTransPslFile, matchedTransToGenomePslFile, unmatchedTransToGenomePslFile)
    return unmatchedCdsToTransAligns

##
# output
##
def _getQNameSet(aligns):
    return frozenset([dropVersion(psl.qName) for psl in aligns])

def _getTNameSet(aligns):
    return frozenset([dropVersion(psl.tName) for psl in aligns])

def problemLog(logFh, reason, transcriptId=None, transcriptType=None, uniprotId=None):
    fileOps.prRowv(logFh, reason, transcriptId, transcriptType, uniprotId)

def reportUnalignedUniprots(uniprotMetaTbl, matchedCdsToTransAligns, logFh):
    alignedUniprotIds = _getQNameSet(matchedCdsToTransAligns)
    unalignedUniprotIds = frozenset(uniprotMetaTbl.byMainIsoAcc.keys()) - alignedUniprotIds
    for uniprotId in sorted(unalignedUniprotIds):
        problemLog(logFh, "uniprot_not_aligned", uniprotId=uniprotId)

def _reportUnmappedTranscript(gencodeMetaTbl, uniprotMetaTbl, unmappedTransAccs, reason, transAcc, logFh):
    transRec = gencodeMetaTbl.byTranscriptAcc.get(transAcc)
    transId = transRec.transcriptId if transRec is not None else None
    uniprotMetas = uniprotMetaTbl.byTranscriptAcc.get(transAcc)
    if transId is None:
        problemLog(logFh, "transcript_not_in_gene_set", transId, None, uniprotMetas[0].mainIsoAcc)
    elif uniprotMetas is None:
        problemLog(logFh, reason, transId, gencodeMetaTbl.getTransType(transId), None)
    else:
        for uniprotMeta in uniprotMetas:
            problemLog(logFh, reason, transId, gencodeMetaTbl.getTransType(transId), uniprotMeta.mainIsoAcc)

def _reportUnmappedTranscripts(gencodeMetaTbl, uniprotMetaTbl, unmappedTransAccs, reason, logFh):
    for transAcc in sorted(unmappedTransAccs):
        _reportUnmappedTranscript(gencodeMetaTbl, uniprotMetaTbl, unmappedTransAccs, reason, transAcc, logFh)

def reportUnpairedMatchedTrans(gencodeMetaTbl, uniprotMetaTbl, matchedCdsTransAligns, logFh):
    alignedTransAccs = _getTNameSet(matchedCdsTransAligns)
    unmappedTransAccs = uniprotMetaTbl.getMatchEnsemblAccSet() - alignedTransAccs

    _reportUnmappedTranscripts(gencodeMetaTbl, uniprotMetaTbl, unmappedTransAccs, "matched_trans_not_mapped", logFh)

def reportUnpairedUnmatchedTrans(gencodeMetaTbl, uniprotMetaTbl, unmatchedCdsToTransAligns, logFh):
    unmatchedTransAccs = gencodeMetaTbl.getCodingTransAccSet() - uniprotMetaTbl.getMatchEnsemblAccSet()
    alignedTransAccs = _getTNameSet(unmatchedCdsToTransAligns)
    unmappedTransAccs = unmatchedTransAccs - alignedTransAccs
    _reportUnmappedTranscripts(gencodeMetaTbl, uniprotMetaTbl, unmappedTransAccs, "unmatched_trans_not_mapped", logFh)

def report(gencodeMetaTbl, uniprotMetaTbl, matchedCdsToTransAligns, unmatchedCdsToTransAligns, problemLogTsv):
    logFh = fileOps.opengz(problemLogTsv, 'w')
    problemLog(logFh, "reason", "transcriptId", "transcriptType", "uniprotId")
    reportUnalignedUniprots(uniprotMetaTbl, matchedCdsToTransAligns, logFh)
    reportUnpairedMatchedTrans(gencodeMetaTbl, uniprotMetaTbl, matchedCdsToTransAligns, logFh)
    reportUnpairedUnmatchedTrans(gencodeMetaTbl, uniprotMetaTbl, unmatchedCdsToTransAligns, logFh)
    logFh.close()

def proteinTranscriptAlign(gencodeMetaTsv, gencodeGpFile, gencodePslFile, uniprotMetaTsv, protTransPslFile,
                           cdsTransPslFile, problemLogTsv, interPrefix):
    gencodeMetaTbl = GencodeMetaTbl(gencodeMetaTsv)
    gencodeDataTbl = GencodeDataTbl(gencodePslFile, gencodeGpFile)
    uniprotMetaTbl = UniProtMetaTbl(uniprotMetaTsv)

    matchedCdsToTransAligns = loadFitlerCdsToTransPsl(uniprotMetaTbl, protTransPslFile)
    unmatchedCdsToTransAligns = projectUniPortAlignments(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl,
                                                         matchedCdsToTransAligns, interPrefix)

    report(gencodeMetaTbl, uniprotMetaTbl, matchedCdsToTransAligns, unmatchedCdsToTransAligns, problemLogTsv)

    writePsls(matchedCdsToTransAligns + unmatchedCdsToTransAligns, cdsTransPslFile)

def main(opts):
    proteinTranscriptAlign(opts.gencodeMetaTsv, opts.gencodeGp, opts.gencodePsl,
                           opts.uniprotMetaTsv, opts.protTransPsl, opts.cdsTransPsl,
                           opts.problemLogTsv, opts.interPrefix)

main(parseArgs())
