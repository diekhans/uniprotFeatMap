#!/usr/bin/env python3

import sys
import os.path as osp
import argparse
from collections import defaultdict
from pycbio.sys import fileOps
from pycbio.hgdata.psl import Psl, PslReader

sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))
from protmap import dropVersion
from protmap.gencode import GencodeMetaTbl, GencodeDataTbl, gencodeMakeCdsPsl
from protmap.uniprot import UniProtMetaTbl, dropUniportIsoformModifier

# Terminology
#    xxxId is id with version
#    xxxAcc is id without version
#
# Algorithm:
#   - Start with alignments of uniprot proteins to match (list in metadats)
#     GENCODE coding transcripts.  These are already filtered for ++ strand
#     and minimal coverage of protein.
#   - If multiple alignments to a matched transcript, pick best one.
#   - Project the matched alignments to other transcript isoforms.  This
#     doesn't consider gene, which allows project to read-through transcripts.
#     Only CDS on other isoforms will have proteins mapped to it by making the
#     UTR unaligned to the genome.

def parseArgs():
    desc = """Filter protein to PSL transcript alignments to pair them based
    on being the listed transcript in UniProt.  Project the primary alignments
    to other transcript isoforms using the genomic coordinates."""

    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("gencodeMetaTsv",
                        help="GENCODE metadata in TSV format UCSC import (not table), which includes tags")
    parser.add_argument("gencodeGp",
                        help="GENCODE annotations in GenePred format")
    parser.add_argument("gencodePsl",
                        help="GENCODE annotations in PSL format")
    parser.add_argument("uniprotMetaTsv",
                        help="Uniprot metadata in TSV format")
    parser.add_argument("protTransPsl",
                        help="protein to transcript alignment PSL")
    parser.add_argument("protTransPairedPsl",
                        help="filtered alignments")
    parser.add_argument("problemLogTsv",
                        help="log file of issues that happened")
    return parser.parse_args()

def problemLogOpen(problemLogTsv):
    logFh = fileOps.opengz(problemLogTsv, 'w')
    fileOps.prRowv(logFh, "reason", "transcriptId", "transcriptType", "key", "uniprotId")
    return logFh

def problemLog(logFh, reason, transcriptId, transcriptType, key=None, uniprotId=None):
    fileOps.prRowv(logFh, reason, transcriptId, transcriptType, key, uniprotId)

##
# data loading, etc
##
def keepCanonicalAlign(uniprotMetaTbl, psl):
    """Only keep alignments from canonical SwissProt isoform, as alt-isoforms to
    a matched transcript"""
    uniprotMeta = uniprotMetaTbl.getByAcc(dropUniportIsoformModifier(psl.qName))
    return ((psl.qName == uniprotMeta.mainIsoAcc) and
            (dropVersion(psl.tName) in uniprotMeta.ensemblTransAccs))

def loadFitlerProtTransPsl(uniprotMetaTbl, protTransPslFile):
    """load aligned PSL and group by SwissProt """
    alignsByProt = defaultdict(list)
    for psl in PslReader(protTransPslFile):
        if keepCanonicalAlign(uniprotMetaTbl, psl):
            alignsByProt[psl.qName].append(psl)
    alignsByProt.default_factory = None
    return alignsByProt

def writePsls(psls, pslFile):
    with fileOps.opengz(pslFile, 'w') as pslFh:
        for psl in sorted(psls, key=Psl.targetKey):
            psl.write(pslFh)

###
# select alignments of canonical proteins to matched transcripts
###
def selectCanonicalProtTransAligns(alignsByProt):
    # most coverage of query
    return [sorted(aligns, key=lambda psl: -psl.queryAligned())[0]
            for aligns in alignsByProt.values()]

###
# Project alignments from UniProt matched transcripts to transcripts isoforms
# that are not matched UniProt.
###

def isUnmatchedMRna(uniprotMetaTbl, transcriptId):
    "should this transcript have an unmatched projected alignment built?"
    return (dropVersion(transcriptId) not in uniprotMetaTbl.ensemblTransAccs)

def writeMRnaGenomeCdsAlign(gencodeDataTbl, transcriptId, tmpPslFh):
    for entry in gencodeDataTbl.getEntries(transcriptId):
        gencodeMakeCdsPsl(entry.alignPsl, entry.annotGp).write(tmpPslFh)

def makeUnmatchMRnaGenomeCdsAligns(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl):
    tmpPslFile = fileOps.tmpFileGet("unmatchedCds-genome", suffix=".psl")
    with open(tmpPslFile, 'w') as tmpPslFh:
        for transcriptId in sorted(gencodeMetaTbl.codingTransIds):
            if isUnmatchedMRna(uniprotMetaTbl, transcriptId):
                writeMRnaGenomeCdsAlign(gencodeDataTbl, transcriptId, tmpPslFh)
    return tmpPslFile

def pslMapCanonicalUnmatches(canonPslFile, cdsPslFile):
    # canonPslFile ->
    pass#

def projectUniPortAlignments(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl, canonicalMatchedAligns):
    # mapping pipeline is:
    #   port->matchTrans => matchTrans->genome => genome->isoTrans => prot->isoTrans

    protMatchTrans = fileOps.tmpFileGet("canon.psl")
    writePsls(canonicalMatchedAligns, canonPslFile)

    unmatchedGenomePslFile = makeUnmatchMRnaGenomeCdsAligns(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl)


##
# output
##
def reportUnpairedTranscripts(gencodeMetaTbl, alignsByTrans, logFh):
    for transId in sorted(alignsByTrans.keys()):
        problemLog(logFh, "no_uniprot_paired", transId, gencodeMetaTbl.getTransType(transId))

def reportUnalignedTranscripts(gencodeMetaTbl, alignsByTrans, pairedByTrans, logFh):
    alignedTransIds = set(alignsByTrans.keys()) | set(pairedByTrans.keys())
    unalignedTransIds = set(gencodeMetaTbl.getCodingTransIds()) - alignedTransIds
    for transId in sorted(unalignedTransIds):
        problemLog(logFh, "no_uniprot_aligned", transId, gencodeMetaTbl.getTransType(transId))

def proteinTranscriptAlign(gencodeMetaTsv, gencodeGpFile, gencodePslFile, uniprotMetaTsv, protTransPslFile, protTransPairedPslFile, problemLogTsv):
    gencodeMetaTbl = GencodeMetaTbl(gencodeMetaTsv)
    gencodeDataTbl = GencodeDataTbl(gencodePslFile, gencodeGpFile)
    uniprotMetaTbl = UniProtMetaTbl(uniprotMetaTsv)

    alignsByProt = loadFitlerProtTransPsl(uniprotMetaTbl, protTransPslFile)
    canonicalMatchedAligns = selectCanonicalProtTransAligns(alignsByProt)
    protTransPairAligns = projectUniPortAlignments(gencodeMetaTbl, gencodeDataTbl, uniprotMetaTbl, canonicalMatchedAligns)

    logFh = problemLogOpen(problemLogTsv)

    #reportUnpairedTranscripts(gencodeMetaTbl, alignsByTrans, logFh)
    #reportUnalignedTranscripts(gencodeMetaTbl, alignsByTrans, pairedByTrans, logFh)

    writePsls(protTransPaired, protTransPairedPsl)
    logFh.close()

def main(opts):
    proteinTranscriptAlign(opts.gencodeMetaTsv, opts.gencodeGp, opts.gencodePsl,
                           opts.uniprotMetaTsv, opts.protTransPsl, opts.protTransPairedPsl,
                           opts.problemLogTsv)

main(parseArgs())
