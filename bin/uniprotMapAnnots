#!/usr/bin/env python3

import sys
import os
import os.path as osp
import argparse
import logging
import pipettor
from pycbio.sys import fileOps, loggingOps
from pycbio.tsv import TsvReader
from pycbio.hgdata.psl import Psl, PslBlock, PslReader

sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))
from uniprotmap.uniprot import UniProtAnnotTbl
from uniprotmap.annotTransRef import annotTransRefCreate, annotTransRefWrite

def parseArgs():
    desc = """
    Map Uniprot annotations to the genome via protein and transcript
    alignments.  The output will be a NA to NA PSL alignments of annotations
    of all annotation types that are mapped.  They can be filtered later when
    building decorators.

    Resulting PSLs will have query name of isoId#annotRowIndex
    """
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--interPrefix",
                        help="""save the intermediate files to names starting with ${iterPrefix}.${name} (output)""")
    parser.add_argument("uniprotAnnotsTsv",
                        help="Uniprot annotations TSV from uniprotToTab (input)")
    parser.add_argument("cdsTransPairedPsl",
                        help="paired protein CDS coordinates to transcript alignments from uniprotProteinTranscriptMap (input)")
    parser.add_argument("transGenomePsl",
                        help="transcript genome alignment; often from genePredToPsl (input)")
    parser.add_argument("annotGenomePsl",
                        help="Uniprot annotations mapped to genome (output)")
    parser.add_argument("annotTransRefTsv",
                        help="association of annotations to mapped transcripts (output)")
    parser.add_argument("problemLogTsv",
                        help="log file of issues that happened (output)")
    loggingOps.addCmdOptions(parser)
    opts = parser.parse_args()
    loggingOps.setupFromCmd(opts)
    pipettor.setDefaultLogger(logging.getLogger())
    return opts

def problemLogOpen(problemLogTsv):
    logFh = open(problemLogTsv, 'w')
    problemLog(logFh, "reason", "uniprotId", "featureType", "annotId", "begin", "end", "protSize")
    return logFh

def problemLog(logFh, reason, mainIsoAcc=None, featType=None, annotId=None, begin=None, end=None, protSize=None):
    fileOps.prRowv(logFh, reason, mainIsoAcc, featType, annotId, begin, end, protSize)

def problemLogAnnot(logFh, reason, annot, protSize=None):
    problemLog(logFh, reason, annot.mainIsoAcc, annot.featType, annot.annotId, annot.begin, annot.end, protSize)

def getProtCdsSizes(cdsTransPairedPsl):
    # protein is query, but in CDS coordinates (3x)
    protCdsSizes = {}
    for psl in PslReader(cdsTransPairedPsl):
        protCdsSizes[psl.qName] = psl.qSize
    return protCdsSizes

def createAnnotPsl(annot, protCdsSizes):
    # qName will have the annotId in the form  mainIsoAcc#annotIdx
    # coordinated converted to CDS coordinates (3x)

    # UniProt is 1-based, open-end
    tStart = 3 * (annot.begin - 1)
    tEnd = 3 * (annot.end - 1)
    tSize = protCdsSizes[annot.mainIsoAcc]

    # some annotations go past the end of the protein
    if tEnd > tSize:
        tEnd = tSize
    qSize = tEnd - tStart

    psl = Psl(qName=annot.annotId, qSize=qSize, qStart=0, qEnd=qSize,
              tName=annot.mainIsoAcc, tSize=tSize, tStart=tStart, tEnd=tEnd,
              strand='+')
    psl.addBlock(PslBlock(qStart=0, tStart=tStart, size=qSize))
    psl.computeCounts()
    return psl

def warnProtNotMapped(annot, warned, logFh):
    # no point if not in sizes, will not map
    key = ('uniport-not-mapped', annot.mainIsoAcc)
    if key not in warned:
        problemLogAnnot(logFh, key[0], annot)
        warned.add(key)

def warnOffEnd(annot, protCdsSize, warned, logFh):
    # some are off the end
    key = ('uniprot-feature-off-end', annot.mainIsoAcc, annot.featType)
    if key not in warned:
        problemLogAnnot(logFh, key[0], annot, protCdsSize // 3)
        warned.add(key)

def annotFilter(annot, protCdsSizes, warned, logFh):
    protCdsSize = protCdsSizes.get(annot.mainIsoAcc, None)
    if protCdsSize is None:
        warnProtNotMapped(annot, warned, logFh)
        return False
    elif annot.begin > (protCdsSize // 3):  # 1-based
        warnOffEnd(annot, protCdsSize, warned, logFh)
        return False
    else:
        return True

def createAnnotPsls(uniprotAnnotTbl, protCdsSizes, annotCanonPslFh, logFh):
    warned = set()
    for annot in uniprotAnnotTbl:
        if annotFilter(annot, protCdsSizes, warned, logFh):
            createAnnotPsl(annot, protCdsSizes).write(annotCanonPslFh)

def writeRef(annotGenomeMapInfo, annotTransRefFh):
    transcriptPos = f"{annotGenomeMapInfo.mappingTName}:{annotGenomeMapInfo.mappingTStart}-{annotGenomeMapInfo.mappingTEnd}"
    annotTransRefWrite(annotTransRefFh, annotGenomeMapInfo.srcQName, transcriptPos, annotGenomeMapInfo.srcTName, annotGenomeMapInfo.mappedPslLine)

def writeRefs(annotGenomeMapInfoTsv, annotTransRefFh):
    for annotGenomeMapInfo in TsvReader(annotGenomeMapInfoTsv):
        if annotGenomeMapInfo.mappedPslLine != "":
            writeRef(annotGenomeMapInfo, annotTransRefFh)

def mkAnnotToTransCmd(annotIsoPsl, cdsTransPairedPsl, annotTransPsl, interPrefix):
    """create command to map annotations to transcripts, all CDS coordinates
    """
    cmd1 = ["pslMap", "-inType=na_na", "-mapType=na_na", "-check",
            annotIsoPsl, cdsTransPairedPsl, annotTransPsl]
    cmd = [cmd1]
    if interPrefix is not None:
        cmd1.append(f"-mapInfo={interPrefix}annotTrans.mapinfo.tsv")
        cmd.append(["tee", f"{interPrefix}annotTrans.psl"])
    return cmd

def mkAnnotToGenomeCmd(annotTransPsl, transGenomePsl, annotGenomePsl, annotGenomeMapInfo):
    """create command to map annotations to genomes
       NA/NA -> NA/NA -> NA/NA
    """
    cmd = ["pslMap", "-inType=na_na", "-mapType=na_na", "-check",
           annotTransPsl, transGenomePsl, annotGenomePsl,
           f"-mapInfo={annotGenomeMapInfo}"]
    return [cmd]

def pslMapAnnots(annotCanonPsl, cdsTransPairedPsl, transGenomePsl,
                 annotGenomePslFh, annotTransRefFh, interPrefix):
    if interPrefix is not None:
        annotGenomeMapInfo = f"{interPrefix}annotGenome.mapinfo.tsv"
    else:
        annotGenomeMapInfo = fileOps.tmpFileGet(prefix="annotGenome.", suffix=".mapinfo.tsv")

    cmd = []

    # NA/NA -> NA/NA -> NA/NA
    cmd += mkAnnotToTransCmd(annotCanonPsl, cdsTransPairedPsl, "/dev/stdout", interPrefix)

    # NA/NA -> NA/NA -> NA/NA
    cmd += mkAnnotToGenomeCmd("/dev/stdin", transGenomePsl, "/dev/stdout", annotGenomeMapInfo)

    pipettor.run(cmd, stdout=annotGenomePslFh)
    writeRefs(annotGenomeMapInfo, annotTransRefFh)

    if interPrefix is None:
        os.unlink(annotGenomeMapInfo)

def uniprotMapAnnots(uniprotAnnotsTsv, cdsTransPairedPsl, transGenomePsl,
                     annotGenomePsl, annotTransRefTsv, problemLogTsv,
                     interPrefix):
    logFh = problemLogOpen(problemLogTsv)
    uniprotAnnotTbl = UniProtAnnotTbl(uniprotAnnotsTsv)
    protCdsSizes = getProtCdsSizes(cdsTransPairedPsl)

    if interPrefix is not None:
        annotCanonPsl = f"{interPrefix}annotCanon.psl"
    else:
        annotCanonPsl = fileOps.tmpFileGet("annotCanon.", ".psl")

    with fileOps.opengz(annotCanonPsl, 'w') as annotCanonPslFh:
        createAnnotPsls(uniprotAnnotTbl, protCdsSizes, annotCanonPslFh, logFh)

    with fileOps.AtomicFileCreate(annotGenomePsl) as annotGenomePslFh:
        with annotTransRefCreate(annotTransRefTsv) as annotTransRefFh:
            pslMapAnnots(annotCanonPsl, cdsTransPairedPsl, transGenomePsl,
                         annotGenomePslFh, annotTransRefFh, interPrefix)

    if interPrefix is None:
        os.unlink(annotCanonPsl)
    logFh.close()

def main(opts):
    uniprotMapAnnots(opts.uniprotAnnotsTsv, opts.cdsTransPairedPsl, opts.transGenomePsl,
                     opts.annotGenomePsl, opts.annotTransRefTsv, opts.problemLogTsv,
                     opts.interPrefix)

main(parseArgs())
