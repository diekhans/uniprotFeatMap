#!/usr/bin/env python3

import sys
import os
import os.path as osp
import argparse
import logging
import pipettor
from pycbio.sys import fileOps, loggingOps
from pycbio.tsv import TsvReader
from pycbio.hgdata.psl import Psl, PslBlock, PslReader

sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))
from protmap.uniprot import UniprotAnnotTbl, canonicalAnnotEncode

def parseArgs():
    desc = """
    Map Uniprot annotations to the genome via protein and transcript
    alignments.  The output will be a NA to NA PSL alignments of annotations
    of all annotation types that are mapped.  They can be filtered later when
    building decorators.

    Resulting PSLs will have query name of isoId#annotRowIndex
    """
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--annotCanonPsl",
                        help="""save the intermediate annotation to canonical PSL""")
    parser.add_argument("--annotIsoPsl",
                        help="""save the intermediate annotation to isoform PSL""")
    parser.add_argument("--annotTransPsl",
                        help="""save the intermediate annotation to transcript PSL""")
    parser.add_argument("--check", action="store_true",
                        help="""validate PSLs alignments, useful for finding bugs""")
    parser.add_argument("uniprotAnnotsTsv",
                        help="Uniprot annotations TSV from uniprotToTab")
    parser.add_argument("isoCanonicalPsl",
                        help="isoform to canonical paired alignments from uniprotIsoCanonicalSelect")
    parser.add_argument("protTransPairedPsl",
                        help="paired protein to transcript alignments from uniprotGencodeSelect")
    parser.add_argument("transGenomePsl",
                        help="transcript genome alignment; often from genePredToPsl")
    parser.add_argument("annotGenomePsl",
                        help="Uniprot annotations mapped to genome")
    parser.add_argument("annotTransRefTsv",
                        help="association of annotations to mapped transcripts")
    loggingOps.addCmdOptions(parser)
    opts = parser.parse_args()
    loggingOps.setupFromCmd(opts)
    pipettor.setDefaultLogger(logging.getLogger())
    return opts

def getCanonProtSizes(isoCanonicalPsl):
    # canonical is target
    canonProtSizes = {}
    for psl in PslReader(isoCanonicalPsl):
        canonProtSizes[psl.tName] = psl.tSize
    return canonProtSizes

def createAnnotPsl(annotIdx, annot, canonProtSizes):
    qName = canonicalAnnotEncode(annot.mainIsoAcc, annotIdx)
    # UniProt is 1-based, open-end
    tStart = annot.begin - 1
    tEnd = annot.end - 1
    tSize = canonProtSizes[annot.mainIsoAcc]

    # some annotations go past the end of the protein
    if tEnd > tSize:
        tEnd = tSize
    qSize = tEnd - tStart

    psl = Psl(qName=qName, qSize=qSize, qStart=0, qEnd=qSize,
              tName=annot.mainIsoAcc, tSize=tSize, tStart=tStart, tEnd=tEnd,
              strand='+')
    psl.addBlock(PslBlock(qStart=0, tStart=tStart, size=qSize))
    psl.computeCounts()
    return psl

def annotFilter(annot, canonProtSizes):
    canonSize = canonProtSizes.get(annot.mainIsoAcc, None)
    if canonSize is None:
        # no point if not in sizes, will not map
        return False
    elif annot.begin > canonSize:  # 1-based
        # some are completely off the end
        return False
    else:
        return True

def createAnnotPsls(uniprotAnnotTbl, canonProtSizes, annotCanonPslFh):
    for annotIdx in range(0, len(uniprotAnnotTbl.df)):
        annot = uniprotAnnotTbl.df.iloc[annotIdx]
        if annotFilter(annot, canonProtSizes):
            createAnnotPsl(annotIdx, annot, canonProtSizes).write(annotCanonPslFh)

def annotTransRefOpen(annotTransRefTsv):
    annotTransRefFh = fileOps.opengz(annotTransRefTsv, 'w')
    fileOps.prRowv(annotTransRefFh, "annotId", "transcriptPos", "transcriptId", "alignIdx")
    return annotTransRefFh

def annotTransRefWrite(annotTransRefFh, annotId, transcriptPos, transcriptId, alignIdx):
    fileOps.prRowv(annotTransRefFh, annotId, transcriptPos, transcriptId, alignIdx)

def writeRefs(mapInfoTmp, annotTransRefFh):
    for row in TsvReader(mapInfoTmp):
        if row.mappedPslLine != "":
            transcriptPos = f"{row.mappingTName}:{row.mappingTStart}-{row.mappingTEnd}"
            annotTransRefWrite(annotTransRefFh, row.srcQName, transcriptPos, row.srcTName, row.mappedPslLine)

def pslMapAnnots(annotCanonPsl, isoCanonicalPsl, protTransPairedPsl, transGenomePsl,
                 annotGenomePslFh, annotTransRefFh, check, annotIsoPsl, annotTransPsl):
    mapInfoTmp = fileOps.tmpFileGet(prefix="mapinfo.")

    checkOpt = ["-check"] if check else []

    # prot/prot -> prot/prot -> prot/prot
    cmd = [["pslMap", "-swapMap", "-inType=prot_prot", "-mapType=prot_prot",
            annotCanonPsl, isoCanonicalPsl, "/dev/stdout"] + checkOpt]
    if annotIsoPsl is not None:
        cmd.append(["tee", annotIsoPsl])

    # prot/prot -> prot/NA -> NA/NA
    cmd.append(["pslMap", "-inType=prot_prot", "-mapType=prot_na",
                "/dev/stdin", protTransPairedPsl, "/dev/stdout"] + checkOpt)
    if annotTransPsl is not None:
        cmd.append(["tee", annotTransPsl])

    # NA/NA -> NA/NA -> NA/NA
    cmd.append(["pslMap", "-inType=na_na", "-mapType=na_na",
                "/dev/stdin", f"-mapInfo={mapInfoTmp}", transGenomePsl, "/dev/stdout"] + checkOpt)
    pipettor.run(cmd, stdout=annotGenomePslFh)

    writeRefs(mapInfoTmp, annotTransRefFh)
    os.unlink(mapInfoTmp)

def uniprotMapAnnots(uniprotAnnotsTsv, isoCanonicalPsl, protTransPairedPsl,
                     transGenomePsl, annotGenomePsl, annotTransRefTsv, check,
                     annotCanonPsl, annotIsoPsl, annotTransPsl):
    uniprotAnnotTbl = UniprotAnnotTbl(uniprotAnnotsTsv)
    canonProtSizes = getCanonProtSizes(isoCanonicalPsl)

    annotCanonPslTmp = annotCanonPsl if annotCanonPsl is not None else fileOps.tmpFileGet("annots.", ".psl.tmp")
    annotTransRefFh = annotTransRefOpen(annotTransRefTsv)
    with fileOps.opengz(annotCanonPslTmp, 'w') as annotCanonPslFh:
        createAnnotPsls(uniprotAnnotTbl, canonProtSizes, annotCanonPslFh)
    if check:
        pipettor.run(["pslCheck", "-verbose=0", annotCanonPslTmp])

    with fileOps.AtomicFileCreate(annotGenomePsl) as annotGenomePslFh:
        pslMapAnnots(annotCanonPslTmp, isoCanonicalPsl, protTransPairedPsl, transGenomePsl,
                     annotGenomePslFh, annotTransRefFh, check, annotIsoPsl, annotTransPsl)

    if annotCanonPsl is None:
        os.unlink(annotCanonPslTmp)
    annotTransRefFh.close()

def main(opts):
    uniprotMapAnnots(opts.uniprotAnnotsTsv, opts.isoCanonicalPsl, opts.protTransPairedPsl, opts.transGenomePsl,
                     opts.annotGenomePsl, opts.annotTransRefTsv, opts.check,
                     opts.annotCanonPsl, opts.annotIsoPsl, opts.annotTransPsl)

main(parseArgs())
