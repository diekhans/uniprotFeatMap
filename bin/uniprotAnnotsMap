#!/usr/bin/env python3

import sys
import os.path as osp
import argparse
import logging
from collections import defaultdict
import pipettor
from pycbio.sys import fileOps, loggingOps
from pycbio.hgdata.psl import Psl, PslBlock, PslReader

sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))
from uniprotmap import TmpOrSaveFile, cleanTmpFiles, annotIdToCanonAcc
from uniprotmap.mapping import pslMapMkCmd, PslMapInfoTbl
from uniprotmap.uniprot import UniProtAnnotTbl
from uniprotmap.metadata import AnnotTransRefWriter

##
# Same-species mapping pipeline:
#     annot2protcds -> protcds2trans -> annot2trans
#     annot2trans -> trans2genome -> annot2genome
#
# Cross-species mapping pipeline:
#     annot2protcds -> protcds2trans -> annot2trans
#     annot2trans -> trans2xsptrans -> annot2xsptrans
#     annot2xsptrans -> trans2genome -> annot2genome
#  Requires an alignment of source transcripts to other species
#  transcripts filtered in some kind of smart way.
#
##
def parseArgs():
    desc = """
    Map Uniprot annotations to the genome via protein and transcript
    alignments.  The output will be a NA to NA PSL alignments of annotations
    of all annotation types that are mapped.  They can be filtered later when
    building decorators.

    Resulting PSLs will have query name of isoId#annotRowIndex

    This maybe also be used to project the mappings to another species by providing
    transcript to transcript alignments.
    """
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--xspeciesTransPsl",
                        help="""PSL alignments of transcripts in the source genome to transcripts in a target genome for cross-species mapping of UniProt features.""")
    parser.add_argument("--interPrefix",
                        help="""Save the intermediate files to names starting with ${iterPrefix}.${name} (output)""")
    parser.add_argument("uniprotAnnotsTsv",
                        help="""Uniprot annotations TSV from uniprotToTab (input)""")
    parser.add_argument("cdsTransPairedPsl",
                        help="""Paired protein to transcript CDS alignments from uniprotProteinTranscriptMap (input)""")
    parser.add_argument("transGenomePsl",
                        help="""Transcript genome alignment; often from genePredToPsl. For cross-species mapping, this should be the target species transcript alignments. (input)""")
    parser.add_argument("annotGenomePsl",
                        help="""Uniprot annotations mapped to genome (output)""")
    parser.add_argument("annotTransRefTsv",
                        help="""Association of annotations to mapped transcripts (output)""")
    parser.add_argument("problemLogTsv",
                        help="""Log file of issues that happened (output)""")
    loggingOps.addCmdOptions(parser)
    opts = parser.parse_args()
    loggingOps.setupFromCmd(opts)
    pipettor.setDefaultLogger(logging.getLogger())
    return opts

class OutOfSyncError(Exception):
    "error when UniProt and mapped files are out-of-sycn "

def problemLogOpen(problemLogTsv):
    logFh = open(problemLogTsv, 'w')
    problemLog(logFh, "reason", "uniprotId", "featureType", "annotId", "begin", "end", "protSize")
    return logFh

def problemLog(logFh, reason, mainIsoAcc=None, featType=None, annotId=None, begin=None, end=None, protSize=None):
    fileOps.prRowv(logFh, reason, mainIsoAcc, featType, annotId, begin, end, protSize)

def problemLogAnnot(logFh, reason, annot, protSize=None):
    problemLog(logFh, reason, annot.mainIsoAcc, annot.featType, annot.annotId, annot.begin, annot.end, protSize)

def getProtCdsSizes(cdsTransPairedPsl):
    # protein is query, but in CDS coordinates (3x)
    protCdsSizes = {}
    for psl in PslReader(cdsTransPairedPsl):
        protCdsSizes[psl.qName] = psl.qSize
    return protCdsSizes

def createAnnotPsl(annot, protCdsSizes):
    # qName will have the annotMapId in the form
    #  <uniprot_acc>|<feature_idx>|<annot_idx>
    # coordinated converted to CDS coordinates (3x)

    # UniProt is 1-based, open-end
    tStart = 3 * (annot.begin - 1)
    tEnd = 3 * (annot.end - 1)
    tSize = protCdsSizes[annot.mainIsoAcc]

    # some features go past the end of the protein (already logged)
    if tEnd > tSize:
        tEnd = tSize
    qSize = tEnd - tStart

    psl = Psl(qName=str(annot.annotId), qSize=qSize, qStart=0, qEnd=qSize,
              tName=annot.mainIsoAcc, tSize=tSize, tStart=tStart, tEnd=tEnd,
              strand='+')
    psl.addBlock(PslBlock(qStart=0, tStart=tStart, size=qSize))
    psl.computeCounts()
    return psl

def warnProtNotMapped(annot, warned, logFh):
    # no point if not in sizes, will not map
    key = ('uniport-protein-not-mapped', annot.mainIsoAcc)
    if key not in warned:
        problemLogAnnot(logFh, key[0], annot)
        warned.add(key)

def warnOffEnd(annot, protCdsSize, warned, logFh):
    # some are off the end; these are partially annotated
    key = ('uniprot-feature-off-end', annot.mainIsoAcc, annot.featType)
    if key not in warned:
        problemLogAnnot(logFh, key[0], annot, protCdsSize // 3)
        warned.add(key)

def annotFilter(annot, protCdsSizes, warned, logFh):
    protCdsSize = protCdsSizes.get(annot.mainIsoAcc, None)
    if protCdsSize is None:
        warnProtNotMapped(annot, warned, logFh)
        return False
    elif annot.begin > (protCdsSize // 3):  # 1-based
        warnOffEnd(annot, protCdsSize, warned, logFh)
        return False
    else:
        return True

def createAnnotPsls(uniprotAnnotTbl, protCdsSizes, annotCanonPslFh, logFh):
    warned = set()
    for annot in uniprotAnnotTbl:
        if annotFilter(annot, protCdsSizes, warned, logFh):
            createAnnotPsl(annot, protCdsSizes).write(annotCanonPslFh)

def buildAnnotCanonPsls(uniprotAnnotTbl, protCdsSizes, interPrefix, logFh):
    annotCanonPsl = TmpOrSaveFile(interPrefix, "annotCanon.psl")
    with fileOps.opengz(annotCanonPsl, 'w') as annotCanonPslFh:
        createAnnotPsls(uniprotAnnotTbl, protCdsSizes, annotCanonPslFh, logFh)
    return annotCanonPsl

def pslMapAnnots(annotCanonPsl, cdsTransPairedPsl, transGenomePsl,
                 annotGenomeMapInfoTsv, xspeciesTransMapInfoTsv,
                 annotGenomePslFh, annotTransRefTsv, xspeciesTransPsl, interPrefix):
    # all of these pslMaps are NA/NA -> NA/NA -> NA/NA
    cmds = []

    # annotation on canonical transcripts to all transcripts alignment to canonical
    cmds += pslMapMkCmd(annotCanonPsl, cdsTransPairedPsl, "/dev/stdout",
                        interPrefix=interPrefix, interMid="annotTrans")
    if xspeciesTransPsl is not None:
        # transcript to other species transcript mapping
        cmds += pslMapMkCmd("/dev/stdin", xspeciesTransPsl, "/dev/stdout",
                            mapInfo=xspeciesTransMapInfoTsv,
                            interPrefix=interPrefix, interMid="xspeciesAnnotTrans")

    # per-transcript annotation to genome mapping
    cmds += pslMapMkCmd("/dev/stdin", transGenomePsl, "/dev/stdout", mapInfo=annotGenomeMapInfoTsv)

    pipettor.run(cmds, stdout=annotGenomePslFh)

def getXSpeciesSrcTrans(mappedTransId, xspeciesTransMapTbl):
    recs = xspeciesTransMapTbl.byMappedTName.get(mappedTransId)
    if recs is None:
        raise Exception(f"Could not find source transcript for cross-species mapped transcript '{mappedTransId}'")
    return recs[0].srcTName

def getA2GUniprotId(transA2GMapInfos):
    return annotIdToCanonAcc(transA2GMapInfos[0].srcQName)

def getA2GUniprotAnnots(uniprotAnnotTbl, transA2GMapInfos):
    uniprotAcc = annotIdToCanonAcc(transA2GMapInfos[0].srcQName)
    return uniprotAnnotTbl.byMainIsoAcc[uniprotAcc]

def mkOutOfSyncAnnotExcept(canonAcc, allAnnots, transA2GMapInfos):
    transcriptId = transA2GMapInfos[0].mappingQName
    errMsg = ([f"UniProt features for {allAnnots[0].mainIsoAcc} out of sync with mapped annotations on {transcriptId}",
               f"number of features {len(allAnnots)}, number of mappings {len(transA2GMapInfos)}",
               "annotations:"] +
              [f"   [{i}] {allAnnots[i].annotId}" for i in range(len(allAnnots))] +
              ["mappings:"] +
              [f"   [{i}] {transA2GMapInfos[i].srcQName}" for i in range(len(transA2GMapInfos))])
    return Exception('\n'.join(errMsg))

def splitByUniprotAcc(transA2GMapInfos):
    "some genes have multiple uniprot entries, split by acc"
    byUniprotAcc = defaultdict(list)
    for transA2GMapInfo in transA2GMapInfos:
        byUniprotAcc[annotIdToCanonAcc(transA2GMapInfo.srcQName)].append(transA2GMapInfo)
    return byUniprotAcc

def writeMappedRef(transA2GMapInfo, transcriptId, transcriptPos, xspeciesSrcTransId, refWriter):
    refWriter.write(transA2GMapInfo.srcQName, transcriptId, transcriptPos,
                    transA2GMapInfo.mappedPslLine, xspeciesSrcTransId)

def writeUnmappedRef(annotId, transcriptId, transcriptPos, xspeciesSrcTransId, refWriter):
    refWriter.write(annotId, transcriptId, transcriptPos, None, xspeciesSrcTransId)

def writeUnmappedRange(allAnnots, iAll, mappedAnnotId, transcriptId, transcriptPos, xspeciesSrcTransId, refWriter):
    # advance all
    while (iAll < len(allAnnots)) and (allAnnots[iAll].annotId != mappedAnnotId):
        writeUnmappedRef(allAnnots[iAll].annotId, transcriptId, transcriptPos, xspeciesSrcTransId, refWriter)
        iAll += 1
        if iAll >= len(allAnnots):
            raise OutOfSyncError(f"mapped annotations our of order or out of sync with uniprot annotation file for '{transcriptId}' and '{mappedAnnotId}'")
    return iAll

def doWriteAllTransRefs(allAnnots, transcriptId, transA2GMapInfos, transcriptPos, xspeciesSrcTransId, refWriter):
    if len(transA2GMapInfos) > len(allAnnots):
        raise OutOfSyncError("more mapped annotations than actually annotations")
    iAll = 0

    for iMapped in range(len(transA2GMapInfos)):
        mappedAnnotId = transA2GMapInfos[iMapped].srcQName
        # unmapped before current
        iAll = writeUnmappedRange(allAnnots, iAll, mappedAnnotId, transcriptId, transcriptPos, xspeciesSrcTransId, refWriter)
        # current
        writeMappedRef(transA2GMapInfos[iMapped], transcriptId, transcriptPos, xspeciesSrcTransId, refWriter)
        iAll += 1
    # remaining unmapped
    for iAll in range(iAll, len(allAnnots)):
        writeUnmappedRef(allAnnots[iAll].annotId, transcriptId, transcriptPos, xspeciesSrcTransId, refWriter)

def writeAllTransRefs(canonAcc, allAnnots, transcriptId, transA2GMapInfos, transcriptPos, xspeciesSrcTransId, refWriter):
    try:
        doWriteAllTransRefs(allAnnots, transcriptId, transA2GMapInfos, transcriptPos, xspeciesSrcTransId, refWriter)
    except OutOfSyncError as ex:
        raise mkOutOfSyncAnnotExcept(canonAcc, allAnnots, transA2GMapInfos) from ex

def writeTransRefs(uniprotAnnotTbl, transcriptId, transA2GMapInfos, xspeciesTransMapTbl, refWriter):
    infos0 = transA2GMapInfos[0]
    transcriptPos = f"{infos0.mappingTName}:{infos0.mappingTStart}-{infos0.mappingTEnd}"
    xspeciesSrcTransId = (getXSpeciesSrcTrans(infos0.mappingQName, xspeciesTransMapTbl)
                          if xspeciesTransMapTbl is not None else None)
    canonAcc = getA2GUniprotId(transA2GMapInfos)
    allAnnots = uniprotAnnotTbl.byMainIsoAcc[canonAcc]
    writeAllTransRefs(canonAcc, allAnnots, transcriptId, transA2GMapInfos, transcriptPos, xspeciesSrcTransId, refWriter)

def writeRefs(uniprotAnnotTbl, annotGenomeMapTbl, xspeciesTransMapTbl, refWriter):
    # split by chrom, to handle PAR, and then by uniprot acc to handle multiple annotations
    for transIdChrom, transA2GMapInfos in sorted(annotGenomeMapTbl.byMappingQMappedTNames.items(), key=lambda v: v[0]):
        for uniprotAcc, uniprotA2GMapInfos in sorted(splitByUniprotAcc(transA2GMapInfos).items(), key=lambda v: v[0]):
            writeTransRefs(uniprotAnnotTbl, transIdChrom[0], uniprotA2GMapInfos, xspeciesTransMapTbl, refWriter)

def mapAnnots(uniprotAnnotTbl, annotCanonPsl, cdsTransPairedPsl, transGenomePsl,
              annotGenomePslFh, annotTransRefTsv, xspeciesTransPsl, interPrefix):
    annotGenomeMapInfoTsv = TmpOrSaveFile(interPrefix, "annotGenome.mapinfo.tsv")
    xspeciesTransMapInfoTsv = None if xspeciesTransPsl is None else TmpOrSaveFile(interPrefix, "xspeciesTrans.mapinfo.tsv")

    pslMapAnnots(annotCanonPsl, cdsTransPairedPsl, transGenomePsl,
                 annotGenomeMapInfoTsv, xspeciesTransMapInfoTsv,
                 annotGenomePslFh, annotTransRefTsv, xspeciesTransPsl, interPrefix)

    annotGenomeMapTbl = PslMapInfoTbl(annotGenomeMapInfoTsv)
    xspeciesTransMapTbl = PslMapInfoTbl(xspeciesTransMapInfoTsv) if xspeciesTransMapInfoTsv is not None else None

    with AnnotTransRefWriter(annotTransRefTsv) as refWriter:
        writeRefs(uniprotAnnotTbl, annotGenomeMapTbl, xspeciesTransMapTbl, refWriter)
    cleanTmpFiles(xspeciesTransMapInfoTsv, annotGenomeMapInfoTsv)

def uniprotAnnotsMap(uniprotAnnotsTsv, cdsTransPairedPsl, transGenomePsl,
                     annotGenomePsl, annotTransRefTsv, problemLogTsv,
                     xspeciesTransPsl, interPrefix):
    uniprotAnnotTbl = UniProtAnnotTbl(uniprotAnnotsTsv)
    protCdsSizes = getProtCdsSizes(cdsTransPairedPsl)

    with problemLogOpen(problemLogTsv) as logFh:
        annotCanonPsl = buildAnnotCanonPsls(uniprotAnnotTbl, protCdsSizes, interPrefix, logFh)

    with fileOps.AtomicFileCreate(annotGenomePsl) as annotGenomePslFh:
        mapAnnots(uniprotAnnotTbl, annotCanonPsl, cdsTransPairedPsl, transGenomePsl,
                  annotGenomePslFh, annotTransRefTsv, xspeciesTransPsl, interPrefix)

    cleanTmpFiles(annotCanonPsl)

def main(opts):
    uniprotAnnotsMap(opts.uniprotAnnotsTsv, opts.cdsTransPairedPsl, opts.transGenomePsl,
                     opts.annotGenomePsl, opts.annotTransRefTsv, opts.problemLogTsv,
                     opts.xspeciesTransPsl, opts.interPrefix)

main(parseArgs())
