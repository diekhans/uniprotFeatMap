#!/usr/bin/env python3

import sys
import os
import os.path as osp
from collections import defaultdict
import argparse
import logging
import pipettor
from pycbio.sys import fileOps, loggingOps
from pycbio.tsv import TsvReader
from pycbio.hgdata.psl import Psl, PslBlock, PslReader

sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))
from uniprotmap.uniprot import UniProtAnnotTbl
from uniprotmap.metadata import annotTransRefCreate, annotTransRefWrite

##
# pipeline
#   annot2protcds -> protcds2trans -> annot2trans
#   [xspecies] annot2trans -> trans2xsptrans -> annot2xsptrans
#   annot2trans -> trans2genome -> annot2genome
##
def parseArgs():
    desc = """
    Map Uniprot annotations to the genome via protein and transcript
    alignments.  The output will be a NA to NA PSL alignments of annotations
    of all annotation types that are mapped.  They can be filtered later when
    building decorators.

    Resulting PSLs will have query name of isoId#annotRowIndex


    This maybe also be used to project the mappings to another species by providing

    """
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--xspeciesTransPsl",
                        help="""PSL alignments of transcripts in the source genome to transcripts in a target genome for cross-species mapping of UniProt features.""")
    parser.add_argument("--interPrefix",
                        help="""Save the intermediate files to names starting with ${iterPrefix}.${name} (output)""")
    parser.add_argument("uniprotAnnotsTsv",
                        help="""Uniprot annotations TSV from uniprotToTab (input)""")
    parser.add_argument("cdsTransPairedPsl",
                        help="""Paired protein CDS coordinates to transcript alignments from uniprotProteinTranscriptMap (input)""")
    parser.add_argument("transGenomePsl",
                        help="""Transcript genome alignment; often from genePredToPsl. For cross-species mapping, this should be the target species transcript alignments. (input)""")
    parser.add_argument("annotGenomePsl",
                        help="""Uniprot annotations mapped to genome (output)""")
    parser.add_argument("annotTransRefTsv",
                        help="""Association of annotations to mapped transcripts (output)""")
    parser.add_argument("problemLogTsv",
                        help="""Log file of issues that happened (output)""")
    loggingOps.addCmdOptions(parser)
    opts = parser.parse_args()
    loggingOps.setupFromCmd(opts)
    pipettor.setDefaultLogger(logging.getLogger())
    return opts

def problemLogOpen(problemLogTsv):
    logFh = open(problemLogTsv, 'w')
    problemLog(logFh, "reason", "uniprotId", "featureType", "annotId", "begin", "end", "protSize")
    return logFh

def problemLog(logFh, reason, mainIsoAcc=None, featType=None, annotId=None, begin=None, end=None, protSize=None):
    fileOps.prRowv(logFh, reason, mainIsoAcc, featType, annotId, begin, end, protSize)

def problemLogAnnot(logFh, reason, annot, protSize=None):
    problemLog(logFh, reason, annot.mainIsoAcc, annot.featType, annot.annotId, annot.begin, annot.end, protSize)

def getProtCdsSizes(cdsTransPairedPsl):
    # protein is query, but in CDS coordinates (3x)
    protCdsSizes = {}
    for psl in PslReader(cdsTransPairedPsl):
        protCdsSizes[psl.qName] = psl.qSize
    return protCdsSizes

def createAnnotPsl(annot, protCdsSizes):
    # qName will have the featAnnotId in the form
    #  <uniprot_acc>|<feature_idx>|<annot_idx>
    # coordinated converted to CDS coordinates (3x)

    # UniProt is 1-based, open-end
    tStart = 3 * (annot.begin - 1)
    tEnd = 3 * (annot.end - 1)
    tSize = protCdsSizes[annot.mainIsoAcc]

    # some features go past the end of the protein (already logged)
    if tEnd > tSize:
        tEnd = tSize
    qSize = tEnd - tStart

    psl = Psl(qName=annot.annotId, qSize=qSize, qStart=0, qEnd=qSize,
              tName=annot.mainIsoAcc, tSize=tSize, tStart=tStart, tEnd=tEnd,
              strand='+')
    psl.addBlock(PslBlock(qStart=0, tStart=tStart, size=qSize))
    psl.computeCounts()
    return psl

def warnProtNotMapped(annot, warned, logFh):
    # no point if not in sizes, will not map
    key = ('uniport-protein-not-mapped', annot.mainIsoAcc)
    if key not in warned:
        problemLogAnnot(logFh, key[0], annot)
        warned.add(key)

def warnOffEnd(annot, protCdsSize, warned, logFh):
    # some are off the end; these are partially annotated
    key = ('uniprot-feature-off-end', annot.mainIsoAcc, annot.featType)
    if key not in warned:
        problemLogAnnot(logFh, key[0], annot, protCdsSize // 3)
        warned.add(key)

def annotFilter(annot, protCdsSizes, warned, logFh):
    protCdsSize = protCdsSizes.get(annot.mainIsoAcc, None)
    if protCdsSize is None:
        warnProtNotMapped(annot, warned, logFh)
        return False
    elif annot.begin > (protCdsSize // 3):  # 1-based
        warnOffEnd(annot, protCdsSize, warned, logFh)
        return False
    else:
        return True

def createAnnotPsls(uniprotAnnotTbl, protCdsSizes, annotCanonPslFh, logFh):
    warned = set()
    for annot in uniprotAnnotTbl:
        if annotFilter(annot, protCdsSizes, warned, logFh):
            createAnnotPsl(annot, protCdsSizes).write(annotCanonPslFh)

def getXSpeciesSrcMap(xspeciesTransMapInfoTsv):
    return {r.mappedTName: r for r in TsvReader(xspeciesTransMapInfoTsv)}

def getXSpeciesSrcTrans(mappedTransId, xspeciesSrcMap):
    if xspeciesSrcMap is None:
        return None
    rec = xspeciesSrcMap.get(mappedTransId)
    if rec is None:
        raise Exception(f"Could not find srcTranscriptId for cross-species mapped transcript '{mappedTransId}'")
    return rec.srcTName

def writeRef(annotGenomeMapInfo, annotIdMapIdxCounter, xspeciesSrcMap, annotTransRefFh):
    annotId = annotGenomeMapInfo.srcQName
    mapIdx = annotIdMapIdxCounter[annotId]
    annotIdMapIdxCounter[annotId] += 1
    transcriptPos = f"{annotGenomeMapInfo.mappingTName}:{annotGenomeMapInfo.mappingTStart}-{annotGenomeMapInfo.mappingTEnd}"
    if xspeciesSrcMap is not None:
        srcTranscriptId = getXSpeciesSrcTrans(annotGenomeMapInfo.mappingQName, xspeciesSrcMap)
    else:
        srcTranscriptId = ""
    annotTransRefWrite(annotTransRefFh, annotId, mapIdx, transcriptPos,
                       annotGenomeMapInfo.srcTName, annotGenomeMapInfo.mappedPslLine, srcTranscriptId)

def writeRefs(annotGenomeMapInfoTsv, xspeciesSrcMap, annotTransRefFh):
    annotIdMapIdxCounter = defaultdict(int)  # to get unique map index for diff transcripts
    for annotGenomeMapInfo in TsvReader(annotGenomeMapInfoTsv):
        if annotGenomeMapInfo.mappedPslLine != "":
            writeRef(annotGenomeMapInfo, annotIdMapIdxCounter, xspeciesSrcMap, annotTransRefFh)

def writeRefsTsv(annotGenomeMapInfoTsv, xspeciesTransMapInfoTsv, annotTransRefTsv):
    xspeciesSrcMap = getXSpeciesSrcMap(xspeciesTransMapInfoTsv) if xspeciesTransMapInfoTsv is not None else None
    with annotTransRefCreate(annotTransRefTsv) as annotTransRefFh:
        writeRefs(annotGenomeMapInfoTsv, xspeciesSrcMap, annotTransRefFh)

def mkAnnotToTransCmd(annotIsoPsl, cdsTransPairedPsl, annotTransPsl, interPrefix):
    """create command to map annotations to transcripts, all CDS coordinates
    """
    cmd1 = ["pslMap", "-tsv", "-inType=na_na", "-mapType=na_na", "-check",
            annotIsoPsl, cdsTransPairedPsl, annotTransPsl]
    cmds = [cmd1]
    if interPrefix is not None:
        cmd1.append(f"-mapInfo={interPrefix}annotTrans.mapinfo.tsv")
        cmds.append(["tee", f"{interPrefix}annotTrans.psl"])
    return cmds

def mkTransToXSpeciesCmd(annotTransPsl, xspeciesTransPsl, xspeciesAnnotTransPsl,
                         xspeciesTransMapInfoTsv, interPrefix):
    """create command to map annotations to transcripts, all CDS coordinates
    """
    cmd1 = ["pslMap", "-tsv", "-inType=na_na", "-mapType=na_na", "-check",
            annotTransPsl, xspeciesTransPsl, xspeciesAnnotTransPsl,
            f"-mapInfo={xspeciesTransMapInfoTsv}"]
    cmds = [cmd1]
    if interPrefix is not None:
        cmds.append(["tee", f"{interPrefix}xspeciesAnnotTransPsl.psl"])
    return cmds

def mkAnnotToGenomeCmd(annotTransPsl, transGenomePsl, annotGenomePsl, annotGenomeMapInfoTsv):
    """create command to map annotations to genomes
       NA/NA -> NA/NA -> NA/NA
    """
    cmd = ["pslMap", "-tsv", "-inType=na_na", "-mapType=na_na", "-check",
           annotTransPsl, transGenomePsl, annotGenomePsl,
           f"-mapInfo={annotGenomeMapInfoTsv}"]
    return [cmd]

def getMapInfoFiles(xspeciesTransPsl, interPrefix):
    """get mapInfo pages from pslMap used when generating the output.  If intermediate files
    are not being saved, temporary files are created"""
    xspeciesTransMapInfoTsv = None
    if interPrefix is not None:
        annotGenomeMapInfoTsv = f"{interPrefix}annotGenome.mapinfo.tsv"
        if xspeciesTransPsl is not None:
            xspeciesTransMapInfoTsv = f"{interPrefix}xspeciesTrans.mapinfo.tsv"
    else:
        annotGenomeMapInfoTsv = fileOps.tmpFileGet(prefix="annotGenome.", suffix=".mapinfo.tsv")
        if xspeciesTransPsl is not None:
            xspeciesTransMapInfoTsv = fileOps.tmpFileGet(prefix="xspeciesTrans.", suffix=".mapinfo.tsv")
    return annotGenomeMapInfoTsv, xspeciesTransMapInfoTsv

def pslMapAnnots(annotCanonPsl, cdsTransPairedPsl, transGenomePsl,
                 annotGenomePslFh, annotTransRefTsv, xspeciesTransPsl, interPrefix):
    annotGenomeMapInfoTsv, xspeciesTransMapInfoTsv = getMapInfoFiles(xspeciesTransPsl, interPrefix)
    cmds = []

    # annotation to transcript mapping
    # NA/NA -> NA/NA -> NA/NA
    cmds += mkAnnotToTransCmd(annotCanonPsl, cdsTransPairedPsl, "/dev/stdout", interPrefix)

    if xspeciesTransPsl is not None:
        # transcript to other species transcript mapping
        # NA/NA -> NA/NA -> NA/NA
        cmds += mkTransToXSpeciesCmd("/dev/stdin", xspeciesTransPsl, "/dev/stdout",
                                     xspeciesTransMapInfoTsv, interPrefix)

    # per-transcript annotation to genome mapping
    # NA/NA -> NA/NA -> NA/NA
    cmds += mkAnnotToGenomeCmd("/dev/stdin", transGenomePsl, "/dev/stdout", annotGenomeMapInfoTsv)

    pipettor.run(cmds, stdout=annotGenomePslFh)
    writeRefsTsv(annotGenomeMapInfoTsv, xspeciesTransMapInfoTsv, annotTransRefTsv)

    if interPrefix is None:
        os.unlink(annotGenomeMapInfoTsv)
        if xspeciesTransMapInfoTsv is not None:
            os.unlink(xspeciesTransMapInfoTsv)

def uniprotAnnotsMap(uniprotAnnotsTsv, cdsTransPairedPsl, transGenomePsl,
                     annotGenomePsl, annotTransRefTsv, problemLogTsv,
                     xspeciesTransPsl, interPrefix):
    uniprotAnnotTbl = UniProtAnnotTbl(uniprotAnnotsTsv)
    protCdsSizes = getProtCdsSizes(cdsTransPairedPsl)

    if interPrefix is not None:
        annotCanonPsl = f"{interPrefix}annotCanon.psl"
    else:
        annotCanonPsl = fileOps.tmpFileGet("annotCanon.", ".psl")

    with problemLogOpen(problemLogTsv) as logFh:
        with fileOps.opengz(annotCanonPsl, 'w') as annotCanonPslFh:
            createAnnotPsls(uniprotAnnotTbl, protCdsSizes, annotCanonPslFh, logFh)

    with fileOps.AtomicFileCreate(annotGenomePsl) as annotGenomePslFh:
        pslMapAnnots(annotCanonPsl, cdsTransPairedPsl, transGenomePsl,
                     annotGenomePslFh, annotTransRefTsv, xspeciesTransPsl, interPrefix)

    if interPrefix is None:
        os.unlink(annotCanonPsl)

def main(opts):
    uniprotAnnotsMap(opts.uniprotAnnotsTsv, opts.cdsTransPairedPsl, opts.transGenomePsl,
                     opts.annotGenomePsl, opts.annotTransRefTsv, opts.problemLogTsv,
                     opts.xspeciesTransPsl, opts.interPrefix)

main(parseArgs())
