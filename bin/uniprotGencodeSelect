#!/usr/bin/env python3

import sys
from os import path as osp
import argparse
from collections import defaultdict
import pandas as pd
from pycbio.sys import fileOps
from pycbio.hgdata.psl import Psl, PslReader

sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))

# Terminology
#    xxxId is id with version
#    xxxAcc is id without version
#
# Algorithm:
#   - start with alignments of uniprot proteins to GENCODE coding transcript,
#     already filtered for ++ strand and minimal coverage of protein
#   - goal to find the best alignment for each transcript:
#     - for each transcript id, if the uniprot entry is part with it by id,
#       us the best covering align of the protein.
#     -

def parseArgs():
    desc = """Filter alignments to pair protein and transcript alignments

    """
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("gencodeMetaTsv",
                        help="GENCODE metadata in TSV format UCSC import (not table), which includes tags")
    parser.add_argument("uniprotMetaTsv",
                        help="Uniprot metadata in TSV format")
    parser.add_argument("protTransPsl",
                        help="protein to transcript alignment PSL")
    parser.add_argument("protTransPairedPsl",
                        help="filtered alignments")
    parser.add_argument("problemLogTsv",
                        help="log file of issues that happened")
    return parser.parse_args()

def problemLogOpen(problemLogTsv):
    logFh = fileOps.opengz(problemLogTsv, 'w')
    fileOps.prRowv(logFh, "reason", "transcriptId", "transcriptType", "key", "uniprotId")
    return logFh

def problemLog(logFh, reason, transcriptId, transcriptType, key=None, uniprotId=None):
    fileOps.prRowv(logFh, reason, transcriptId, transcriptType, key, uniprotId)

def dropVersion(ident):
    # might be NaN
    return ident.split('.')[0]

def splitMetaList(val):
    """ split strings like: ENST00000369413.8|ENST00000528909.1"""
    return val.split('|')

def splitDropVersion(idents):
    return [dropVersion(id) for id in splitMetaList(idents)]

def dropUniportIsoformModifier(acc):
    return acc.split('-')[0]

class GencodeMetadata:
    def __init__(self, gencodeMetaTsv):
        self.df = pd.read_table(gencodeMetaTsv, keep_default_na=False)

    def getTrans(self, transId):
        transes = self.df[self.df.transcriptId == transId]
        if len(transes) == 0:
            raise Exception(f"can't find GENCODE metadata for '{transId}'")
        return transes.iloc[0]

    def getGeneId(self, transId):
        return self.getTrans(transId).geneId

    def getGeneName(self, transId):
        return self.getTrans(transId).geneName

    def getCodingTransIds(self):
        return list(self.df[self.df.transcriptClass == 'coding'].transcriptId)

    def getTransType(self, transId):
        return self.getTrans(transId).transcriptType

class UniprotMeta:
    def __init__(self, uniprotMetaTsv):
        self.df = pd.read_table(uniprotMetaTsv, keep_default_na=False)

        # index by gene and transcript ids
        self.df['ensemblGeneAccs'] = self.df.ensemblGene.apply(splitDropVersion)
        self.df['ensemblTransAccs'] = self.df.ensemblTrans.apply(splitDropVersion)
        self.byGeneAccDf = self.df.explode('ensemblGeneAccs')
        self.byGeneAccDf.rename(columns={'ensemblGeneAccs': 'ensemblGeneAcc'}, inplace=True)
        self.byTranscriptAccDf = self.df.explode('ensemblTransAccs')
        self.byTranscriptAccDf.rename(columns={'ensemblTransAccs': 'ensemblTransAcc'}, inplace=True)

    def getTransMeta(self, transAcc):
        protMetas = self.byTranscriptAccDf[self.byTranscriptAccDf.ensemblTransAcc == transAcc]
        if len(protMetas) == 0:
            return None
        if len(protMetas) > 1:
            raise Exception(f"excepted no more than protein for transcript {transAcc}, found: {protMetas.mainIsoAcc}")
        return protMetas.iloc[0]

    def getGeneAccMetas(self, geneAcc):
        protMetas = self.byGeneAccDf[self.byGeneAccDf.ensemblGeneAcc == geneAcc]
        if len(protMetas) == 0:
            return None
        return protMetas

    def getGeneNameMetas(self, geneName):
        protMetas = self.byGeneAccDf[self.byGeneAccDf.geneName == geneName]
        if len(protMetas) == 0:
            return None
        return protMetas

def keepAlign(uniprotMeta, psl):
    # ignored PAR_Y (e.g. ENST00000359512.8_PAR_Y)
    if psl.tName.endswith("_PAR_Y"):
        return False
    # only keep alignments from main SwissProt isoform, as alt-isoforms are
    # not annotated
    return not uniprotMeta.df.mainIsoAcc.isin([psl.qName]).empty

def loadProtTransPsl(uniprotMeta, protTransPsl):
    alignsByTrans = defaultdict(list)  # by stable trans id
    for psl in PslReader(protTransPsl):
        if keepAlign(uniprotMeta, psl):
            alignsByTrans[psl.tName].append(psl)
    alignsByTrans.default_factory = None
    return alignsByTrans

def selectAlignByProtAccs(aligns, protAccs):
    protAligns = [psl for psl in aligns if psl.qName in protAccs]
    if len(protAligns) == 0:
        return None
    # most coverage of query
    return sorted(protAligns, key=lambda psl: -psl.queryAligned())[0]

###
# functions that are applied to get the best matching alignment based
# on various ways to obtain proteins associated with a transcript.
###

def pairTransByUniprotTransId(gencodeMeta, uniprotMeta, transId, aligns, logFh):
    protMeta = uniprotMeta.getTransMeta(dropVersion(transId))
    if protMeta is None:
        return None
    protAlign = selectAlignByProtAccs(aligns, [protMeta.mainIsoAcc])
    if protAlign is None:
        problemLog(logFh, "no_uniprot_trans_id_aligns", transId, gencodeMeta.getTransType(transId),
                   transId, protMeta.mainIsoAcc)
    return protAlign

def pairTransByUniprotGeneId(gencodeMeta, uniprotMeta, transId, aligns, logFh):
    geneId = gencodeMeta.getGeneId(transId)
    protMetas = uniprotMeta.getGeneAccMetas(dropVersion(geneId))
    if protMetas is None:
        return None
    protAlign = selectAlignByProtAccs(aligns, frozenset(protMetas.mainIsoAcc))
    if protAlign is None:
        problemLog(logFh, "no_uniprot_gene_id_aligns", transId, gencodeMeta.getTransType(transId),
                   geneId, ",".join(protMetas.mainIsoAcc))
    return protAlign

def pairTransByUniprotGeneName(gencodeMeta, uniprotMeta, transId, aligns, logFh):
    geneName = gencodeMeta.getGeneName(transId)
    protMetas = uniprotMeta.getGeneNameMetas(geneName)
    if protMetas is None:
        return None
    protAlign = selectAlignByProtAccs(aligns, frozenset(protMetas.mainIsoAcc))
    if protAlign is None:
        problemLog(logFh, "no_uniprot_gene_name_aligns", transId, gencodeMeta.getTransType(transId),
                   geneName, ",".join(protMetas.mainIsoAcc))
    return protAlign

###
# processing of alignments
###
def selectUniprotTransPairs(gencodeMeta, uniprotMeta, selectFunc, alignsByTrans, pairedByTrans, logFh):
    """Select alignments base on a function that pairs a protein to a
    transcript by some criteria.  Call this function in order of most strict to least
    strict functions.  Only one alignment is kept per transcript.  The
    alignments are moved from alignsByTrans to pairedByTrans as the are select and return.
    """
    protTransPaired = []
    transIds = sorted(alignsByTrans.keys())  # copy due to modification
    for transId in transIds:
        selectedAln = selectFunc(gencodeMeta, uniprotMeta, transId, alignsByTrans[transId], logFh)
        if selectedAln is not None:
            protTransPaired.append(selectedAln)
            pairedByTrans[transId] = alignsByTrans[transId]
            del alignsByTrans[transId]
    return protTransPaired

def reportUnpairedTranscripts(gencodeMeta, alignsByTrans, logFh):
    for transId in sorted(alignsByTrans.keys()):
        problemLog(logFh, "no_uniprot_paired", transId, gencodeMeta.getTransType(transId))

def reportUnalignedTranscripts(gencodeMeta, alignsByTrans, pairedByTrans, logFh):
    alignedTransIds = set(alignsByTrans.keys()) | set(pairedByTrans.keys())
    unalignedTransIds = set(gencodeMeta.getCodingTransIds()) - alignedTransIds
    for transId in sorted(unalignedTransIds):
        problemLog(logFh, "no_uniprot_aligned", transId, gencodeMeta.getTransType(transId))

def writePairedPsl(fh, protTransPaired):
    for psl in sorted(protTransPaired, key=Psl.targetKey):
        psl.write(fh)

def proteinTranscriptAlign(gencodeMetaTsv, uniprotMetaTsv, protTransPsl, protTransPairedPsl, problemLogTsv):
    gencodeMeta = GencodeMetadata(gencodeMetaTsv)
    uniprotMeta = UniprotMeta(uniprotMetaTsv)
    alignsByTrans = loadProtTransPsl(uniprotMeta, protTransPsl)
    pairedByTrans = {}

    logFh = problemLogOpen(problemLogTsv)

    # alignsByTrans is cleared as alignments add to protTransPaired
    protTransPaired = selectUniprotTransPairs(gencodeMeta, uniprotMeta, pairTransByUniprotTransId, alignsByTrans, pairedByTrans, logFh)
    protTransPaired += selectUniprotTransPairs(gencodeMeta, uniprotMeta, pairTransByUniprotGeneId, alignsByTrans, pairedByTrans, logFh)
    protTransPaired += selectUniprotTransPairs(gencodeMeta, uniprotMeta, pairTransByUniprotGeneName, alignsByTrans, pairedByTrans, logFh)

    reportUnpairedTranscripts(gencodeMeta, alignsByTrans, logFh)
    reportUnalignedTranscripts(gencodeMeta, alignsByTrans, pairedByTrans, logFh)

    with fileOps.opengz(protTransPairedPsl, 'w') as fh:
        writePairedPsl(fh, protTransPaired)
    logFh.close()

def main(opts):
    proteinTranscriptAlign(opts.gencodeMetaTsv, opts.uniprotMetaTsv, opts.protTransPsl, opts.protTransPairedPsl,
                           opts.problemLogTsv)

main(parseArgs())
