#!/usr/bin/env python3

import sys
from os import path as osp
import argparse
from collections import defaultdict
from pycbio.sys import fileOps
from pycbio.hgdata.psl import Psl, PslReader

sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))
from protmap import dropVersion
from protmap.gencode import GencodeMetadata
from protmap.uniprot import UniprotMeta

# Terminology
#    xxxId is id with version
#    xxxAcc is id without version
#
# Algorithm:
#   - start with alignments of uniprot proteins to GENCODE coding transcript,
#     already filtered for ++ strand and minimal coverage of protein
#   - goal to find the best alignment for each transcript:
#     - for each transcript id, if the uniprot entry is part with it by id,
#       us the best covering align of the protein.
#     -

def parseArgs():
    desc = """Filter alignments to pair protein and transcript alignments

    """
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("gencodeMetaTsv",
                        help="GENCODE metadata in TSV format UCSC import (not table), which includes tags")
    parser.add_argument("uniprotMetaTsv",
                        help="Uniprot metadata in TSV format")
    parser.add_argument("protTransPsl",
                        help="protein to transcript alignment PSL")
    parser.add_argument("protTransPairedPsl",
                        help="filtered alignments")
    parser.add_argument("problemLogTsv",
                        help="log file of issues that happened")
    return parser.parse_args()

def problemLogOpen(problemLogTsv):
    logFh = fileOps.opengz(problemLogTsv, 'w')
    fileOps.prRowv(logFh, "reason", "transcriptId", "transcriptType", "key", "uniprotId")
    return logFh

def problemLog(logFh, reason, transcriptId, transcriptType, key=None, uniprotId=None):
    fileOps.prRowv(logFh, reason, transcriptId, transcriptType, key, uniprotId)

def keepAlign(uniprotMeta, psl):
    # only keep alignments from main SwissProt isoform, as alt-isoforms are
    # not annotated
    return not uniprotMeta.df.mainIsoAcc.isin([psl.qName]).empty

def loadProtTransPsl(uniprotMeta, protTransPsl):
    alignsByTrans = defaultdict(list)  # by stable trans id
    for psl in PslReader(protTransPsl):
        if keepAlign(uniprotMeta, psl):
            alignsByTrans[psl.tName].append(psl)
    alignsByTrans.default_factory = None
    return alignsByTrans

def selectAlignByProtAccs(aligns, protAccs):
    protAligns = [psl for psl in aligns if psl.qName in protAccs]
    if len(protAligns) == 0:
        return None
    # most coverage of query
    return sorted(protAligns, key=lambda psl: -psl.queryAligned())[0]

###
# functions that are applied to get the best matching alignment based
# on various ways to obtain proteins associated with a transcript.
###

def pairTransByUniprotTransId(gencodeMeta, uniprotMeta, transId, aligns, logFh):
    protMeta = uniprotMeta.getTransMeta(dropVersion(transId))
    if protMeta is None:
        return None
    protAlign = selectAlignByProtAccs(aligns, [protMeta.mainIsoAcc])
    if protAlign is None:
        problemLog(logFh, "no_uniprot_trans_id_aligns", transId, gencodeMeta.getTransType(transId),
                   transId, protMeta.mainIsoAcc)
    return protAlign

def pairTransByUniprotGeneId(gencodeMeta, uniprotMeta, transId, aligns, logFh):
    geneId = gencodeMeta.getGeneId(transId)
    protMetas = uniprotMeta.getGeneAccMetas(dropVersion(geneId))
    if protMetas is None:
        return None
    protAlign = selectAlignByProtAccs(aligns, frozenset(protMetas.mainIsoAcc))
    if protAlign is None:
        problemLog(logFh, "no_uniprot_gene_id_aligns", transId, gencodeMeta.getTransType(transId),
                   geneId, ",".join(protMetas.mainIsoAcc))
    return protAlign

def pairTransByUniprotGeneName(gencodeMeta, uniprotMeta, transId, aligns, logFh):
    geneName = gencodeMeta.getGeneName(transId)
    protMetas = uniprotMeta.getGeneNameMetas(geneName)
    if protMetas is None:
        return None
    protAlign = selectAlignByProtAccs(aligns, frozenset(protMetas.mainIsoAcc))
    if protAlign is None:
        problemLog(logFh, "no_uniprot_gene_name_aligns", transId, gencodeMeta.getTransType(transId),
                   geneName, ",".join(protMetas.mainIsoAcc))
    return protAlign

###
# processing of alignments
###
def selectUniprotTransPairs(gencodeMeta, uniprotMeta, selectFunc, alignsByTrans, pairedByTrans, logFh):
    """Select alignments base on a function that pairs a protein to a
    transcript by some criteria.  Call this function in order of most strict to least
    strict functions.  Only one alignment is kept per transcript.  The
    alignments are moved from alignsByTrans to pairedByTrans as the are select and return.
    """
    protTransPaired = []
    transIds = sorted(alignsByTrans.keys())  # copy due to modification
    for transId in transIds:
        selectedAln = selectFunc(gencodeMeta, uniprotMeta, transId, alignsByTrans[transId], logFh)
        if selectedAln is not None:
            protTransPaired.append(selectedAln)
            pairedByTrans[transId] = alignsByTrans[transId]
            del alignsByTrans[transId]
    return protTransPaired

def reportUnpairedTranscripts(gencodeMeta, alignsByTrans, logFh):
    for transId in sorted(alignsByTrans.keys()):
        problemLog(logFh, "no_uniprot_paired", transId, gencodeMeta.getTransType(transId))

def reportUnalignedTranscripts(gencodeMeta, alignsByTrans, pairedByTrans, logFh):
    alignedTransIds = set(alignsByTrans.keys()) | set(pairedByTrans.keys())
    unalignedTransIds = set(gencodeMeta.getCodingTransIds()) - alignedTransIds
    for transId in sorted(unalignedTransIds):
        problemLog(logFh, "no_uniprot_aligned", transId, gencodeMeta.getTransType(transId))

def writePairedPsl(fh, protTransPaired):
    for psl in sorted(protTransPaired, key=Psl.targetKey):
        psl.write(fh)

def proteinTranscriptAlign(gencodeMetaTsv, uniprotMetaTsv, protTransPsl, protTransPairedPsl, problemLogTsv):
    gencodeMeta = GencodeMetadata(gencodeMetaTsv)
    uniprotMeta = UniprotMeta(uniprotMetaTsv)
    alignsByTrans = loadProtTransPsl(uniprotMeta, protTransPsl)
    pairedByTrans = {}

    logFh = problemLogOpen(problemLogTsv)

    # alignsByTrans is cleared as alignments add to protTransPaired
    protTransPaired = selectUniprotTransPairs(gencodeMeta, uniprotMeta, pairTransByUniprotTransId, alignsByTrans, pairedByTrans, logFh)
    protTransPaired += selectUniprotTransPairs(gencodeMeta, uniprotMeta, pairTransByUniprotGeneId, alignsByTrans, pairedByTrans, logFh)
    protTransPaired += selectUniprotTransPairs(gencodeMeta, uniprotMeta, pairTransByUniprotGeneName, alignsByTrans, pairedByTrans, logFh)

    reportUnpairedTranscripts(gencodeMeta, alignsByTrans, logFh)
    reportUnalignedTranscripts(gencodeMeta, alignsByTrans, pairedByTrans, logFh)

    with fileOps.opengz(protTransPairedPsl, 'w') as fh:
        writePairedPsl(fh, protTransPaired)
    logFh.close()

def main(opts):
    proteinTranscriptAlign(opts.gencodeMetaTsv, opts.uniprotMetaTsv, opts.protTransPsl, opts.protTransPairedPsl,
                           opts.problemLogTsv)

main(parseArgs())
